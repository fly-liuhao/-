## Java OOP第1~2单元

#### 面向对象特性
1. 封装
2. 继承
3. 多态
4. 抽象
> 封装的目的：保护数据
>继承的目的：类的复用
>多态的目的：增强程序的复用性，解耦。

#### 访问控制
> 访问控制：控制类外面可以访问类中的那些属性和方法；
1. 访问控制符号：用于修饰属性和方法/（类）

    |修饰符|本类内部|同包中的类|子类|包外其它类
    |:--:|:--:|:--:|:--:|:--:|
    |public|可以访问|可以访问|可以访问|可以访问
    |protected|可以访问|可以访问|可以访问|不能访问
    |默认|可以访问| 可以访问|不能访问|不能访问
    |private|可以访问|不能访问|不能访问|不能访问

2. 访问控制符修饰类：
- 对于类的修饰可以使用public和默认（default）方式；
- public修饰的类可以被任何一个类使用；
- 默认的访问控制的类只能被同包中的类使用；



#### 封装
1. 什么是封装：就是将数据和对数据的操作集中的定义在对象中，外界仅能通过对象提供的接口访问对象的属性和功能;
    -  属性私有(private)
    -  提供公共方法访问(public)
3. 封装的意义：对外提供可调用的、稳定的功能；
4. 封装内部具体的实现细节，外界不可访问，这样的好处在于：降低出错的可能性；
5. 内部变化，不会影响外部使用；

#### 继承
1. 什么是继承：类的复用---即使用现有类的定义复制并扩展出另一个新的类定义，子类可以继承父类中的成员变量和成员方法(不包含构造)，同时也可以定义自己的成员变量和成员方法；
    > 泛化：从多个类中，抽取相同部分，生成父类的过程叫做泛化；
    >设计时，从子类泛化出公共父类，再让子类继承父类；    


2. Java语言不支持多重继承，一个类只能继承一个父类，但一个父类可以有多个子类；
 - 面试题：一个类只能有一个父类？不一定---A->B->C
3. 继承的语法规则？extends
    ```java
    Class Person {
      //...
    }
    Class Student extends Person {
      //...
    }
    ```
4. 继承要求：取决于父类的访问控制符
- 同一包中继承：子类可以访问父类访问控制符为：public、protected、以及默认（default）的属性即方法；
- 跨包继承：默认情况下，只要不在一个包内，即使是继承也无法访问父类的默认访问控制的属性及其方法
  - 类中访问：
  若子类需要访问父类属性或方法：要求父类属性及方法访问权限最低要是protected（public、protected）;
  - 类外访问：
  子类对象只能直接访问子类从父类继承的访问控制符为【public】的属性或方法；
若子类需要访问父类中protected修饰的方法：子类需要使用重写通过super来调用父类的方法；
(java中规定：子类重写父类的方法，子类的方法访问控制范围不能小于父类方法的访问控制范围)
5. 继承关系下，父类的构造方法调用问题？
- 创建子类对象的时候，父类的默认构造方法会默认调用
- 父类没有构造方法时，子类的构造函数需要使用super()指定父类的构造方法
- super()必须放在子类构造方法的第一行
6. 对象的构造次序如何？
- 继承关系是自下而上---子类继承于父类
- 构造函数调用是自上而下---先完成父类的构造，再完成子类的构造

7. 方法的重写（Override）：
- 原因：继承于父类的方法无法满足子类的需要
- 方法名、参数列表（数据类型、个数、次序）、返回值类型相同，访问控制相同或者更加宽泛
- 父类构造方法不能被继承，所以不能被重写
  > @Override : 断言机制。就是告诉编译器当前方法是重写父类方法，
  >请编译器协助检查方法签名，如果重写的方法签名在父类中没有找到，则编译错误；

8. 方法的重载（Overload）：一个类中有多个同名方法
- 规则：方法名字相同，参数列表必须不同，返回值和访问控制符不限
- 构造方法可以重载

9. this的使用：
- this表示当前类的对象
- 使用this()调用本类自己的构造方法
- this.(属性/方法),调用本类的属性和一般方法
10. shper的使用：
- super表示父类的对象
- 使用super()调用父类的构造方法
- 使用super.(属性/方法)，在子类中调用父类的属性和一般方法
>this()和supr()不能同时调用，都需要放在构造方法体的首行

12. 创建子类对象时，程序执行过程?
- 父子类当中只有无参构造方法：先执行父类构造后执行子类构造
- 父类子类中属性赋值动作，赋值也是先赋值完父类的属性值，再赋值子类的属性， 代码执行时先给属性赋值，再执行方法。
- 父子类有游离块：看代码位置
>属性赋值顺序：隐式初值-->显示赋值-->构造赋值

13. **父类的引用指向子类的对象**
- 父类的引用可以指向子类的对象，但通过父类的引用只能访问父类自己定义的属性和功能部分（包含子类重写父类的方法），不能访问子类扩展的部分（独有的属性和功能）
- 例如Person类型的对象，就无法访问子类Student的成绩这个属性
14. 动态方法调度
- 在运行时，父类变量根据指向子类对象的不同，动态判断调用何种重写方法
  ```java
  /*动态方法调度*/
  Person dad = null;
  Child1 = son1 = new Child1();
  Child2 = son2 = new Child2();

  //爸爸和大儿子一起做蛋炒饭
  dad = son1;
  dad.cook;

  //爸爸和二儿子一起包饺子
  dad = son2;
  dad.cook;
  ```
15. 笔试题（重写和重载的区别&&父类的引用指向子类的对象）
    ```java
    //下面代码输出结果是？
    class Super {
        public void f() {
            System.out.println("super.f()");
        }
    }

    class Sub extends Super {
        public void f() {
            System.out.println("sub.f()");
        }
    }

    class Goo {
        public void g(Super obj) {
            System.out.println("g(Super)");
            obj.f();
        }

        public void g(Sub obj) {
            System.out.println("g(Sub)");
        }
    }
    class Test{
        public static void main(String[] args) {
            Super obj = new Sub();
            Goo goo = new Goo();
            goo.g(obj);
        }
    }


    //结果
    g(Super)
    sub.f()
    /*
    注意：如果父类Super中没有f()方法，那么这道题的输出结果就是编译错误；
    原因是：父类中没有f()方法，子类中的f()方法就不是重写，所以父类定义的引用变量obj就不能访问子类的成员方法/（非重写方法）！
    */
    ```
