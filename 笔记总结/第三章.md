# 第三章 Java 第三阶段
## 第一节：Java开发起步
### 一、前期准备
#### （一）下载安装JDK
[Jdk下载官网](https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html)

#### （二）配置环境变量
  需要配置的两个环境变量：

  1. Path:可执行文件路径(路径指向jdk的bin路径)
  2. CLASSPATH：类路径，值是 .;
  > 分号不能是汉字输入法下的
  - 问题：Path和CLASSPATH大小写区分吗？
    在Windows下不区分，在Linux, Unix, Mac下必须是Path,CLASSPATH
  - 问题：Windows环境下，用户变量和系统变量一样，谁会生效？
    用户变量生效，系统变量会被覆盖
####（三）验证环境变量配置是否成功
1. 验证方式一：javac, java
- 问题：javac和java从哪里来？
Path环境变量的值，就是JDK的bin目录
2. 验证方式二：set命令(可查可改)
使用set classpath或者 set path，查看显示的是否正确。
在set设置时，设置结果仅对当前控制台或者命令行窗口有效，控制台关闭，set结果失效。
> Win+R 输入sysdm.cpl 进入高级->环境变量
####（四）编写HelloWorld程序，不带包
- 编写Java代码的工具：Java文件实际上就是文本文件。
eg：记事本、Atom、Notepad++、EditPlus(商业)、Sublime、VS Code
- 注意事项：
    1. 必须加规范的注释(版权注释，JavaDoc注释)
    2. 缩进4个空格
    3. 类名，方法名后加一个空格
    4. Java严格区分大小写
    5. 编译：javac HelloWorld.java
  > 有GBK中文问题时，这样输入 javac -encoding utf-8 HelloWorld.java
   DOS命令：
  >            切换到D盘：        D:+enter
  >            显示当前目录：     dir
  >            退回到上级目录：   cd ..
  >            退回至根目录：     cd \
  >            补全命令           首字母+tab键
####（五）编写HelloWorld，带包
- 编译方法：javac -d . HelloWorld.java
  > "."表示在当前目录下
  执行方法：java cn.edu.tit.corejava.Day01.HelloWorld
####（六）在一个Java文件中编写多个类
```java
public class Person {
	public static void main(String []args) {
		System.out.println("Person");
	}
}

class Student {
	public static void main(String []args) {
		System.out.println("Student");
	}
}

class Teacher {
	public static void main(String []args) {
		System.out.println("Teacher");
	}
}
```
- 问题1：将Person.java另存为Student.java,为什么编译无法通过？
    如果一个类被public修饰时，保存文件时，文件名和此类名命名一致
- 问题2：将Student修饰为public，为什么无法通过编译？
    一个Java文件中，最多只能有一个类被public修饰。
    如果所有类都不是public，文件名可以自己命名
> .class文件叫字节码文件，使用内存地址+16进制编码表示， 以CAFEBABE开头
####（七）配置并使用Eclipse
+ 什么是IDE？集成开发环境
+ 主要的IDE有哪些？Eclipse(免费)，IDEA(商业)，NetBeans(免费的，来自sun公司)
[Eclipse下载官网](https://www.eclipse.org/downloads/packages/)
从官网上下载后得到一个压缩包，解压即可使用(绿色软件)
+ Eclipse使用先决条件：
    先安装JDK，并配置好环境变量，
    注意：JDK的位数与Eclipse的位数一致
    Eclipse的版本和它匹配的JDK版本要一致，如果Eclipse要求JDK8，那么最好是安装JDK8(软件一般向下兼容)
+ 术语介绍：
    1. 工作空间 Workspace,存放写好的项目
    2. 工程或者项目，在写程序前必须先建立工程
+ 正式使用前必须配置Eclipse
    1. 配置编码，utf-8（处理乱码）
    ![配置编码](https://github.com/lichuangbo/markdown-images/raw/master/CoreJava%20images/utf-8.jpg)
    2. 配置JDK
    ![JDK](https://github.com/lichuangbo/markdown-images/raw/master/CoreJava%20images/JDK.jpg)
    3. 配置自动提示
    ![自动提示](https://github.com/lichuangbo/markdown-images/raw/master/CoreJava%20images/%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA.jpg)
+ Eclipse如何使用？
    1. 如何建立工程或者项目？
    2. 如何编写HelloWorld程序？
        执行HelloWorld方式：鼠标点击
        ctrl + F11 或者 ALT + SHIFT + X,J
    3. Eclipse常用的快捷键
        > 任务：搜索Eclipse快捷键
        Ctrl + M:   放大或者还原代码编辑窗口
        Ctrl + W:   关闭当前编辑的窗口
        Ctrl + Shift + W: 关闭所有编辑窗口
        Ctrl + E:     结合上下键，切换编辑窗口
        Ctrl + D:     删除光标所在行
        Shift + Enter:在光标所在行后，另起一行
        Ctrl + Shift + Enter:在光标所在行前，另起一行
        Alt + 上下键： 移动代码行的位置
        Alt + 左键：     回到前一编辑页面
        Alt + 右键：     回到后移编辑页面
        Ctrl + /:单行注释
        Ctrl + Shift + /:多行注释
        Ctrl + Shift + \:取消多行注释
        Ctrl + L:      快速定位行
        Ctrl + Q:      回到上次操作行
        Ctrl + Shift + F:格式化代码(代码无error,搜狗输入法关闭)
        Alt + Shift + S: 自动补充代码
        Ctrl + Alt + 下键： 复制当前行到下一行
        Ctrl + Alt + 上键： 复制当前行到上一行
        Ctrl + Shift + P:定位到下一匹配符(括号的匹配)
    4. 如何安装Eclipse插件(plugin)？
        - 打开文件路径的插件 OpenExplorer
        复制插件的jar包，放置到Eclipse的plugins目录中；
        重启Eclipse，如果不生效，删除Eclipse目录下的configuration的org.eclipse.update，重启若还是不生效可能是版本不匹配
        - 安装阿里巴巴的代码审查工具
        Help->Install New Software-> 将"https://p3c.alibaba.com/plugin/eclipse/update"这段网址复制在Work with目录下
        ->点击Add(为工具命名)->next->select all勾选上->一路next安装完毕
        使用：
            右键->选择"阿里编码规范检查"->如有不规范代码会显示出来
### 二、了解Java
#### （一）HelloWorld程序解析
args 是arguments的缩写，一般默认写为args，是可以修改的
String[] args 这个字符串数组是保存运行main函数时输入的参数的
1. 去掉类前面的修饰符，程序能否编译和执行？
	+ 去掉类前public：编译通过，执行通过！
2. 去掉main前面的修饰符，程序能否编译和执行？
    + 去public：能通过编译，不能执行(找不到main方法)
    + 去static: 能通过编译，不能执行(main 方法不是类 HelloWorld 中的static)
    + 去void: 不能通过编译(方法声明无效，需要返回值类型)
3. main前面的修饰符调换位置，程序能否编译和执行？
    + public与static: 编译通过，执行通过！
    + void与main: 不能通过编译
    + static与void：不能通过编译
    + public与void：不能通过编译
4. 去掉main中形参，程序能否编译和执行？
    + 空：能通过编译，不能执行(找不到main方法)
    + 去String: 不能通过编译(非法类型开始)，不能执行(找不到main方法)
    + 去args: 不能通过编译(需要标识符)，不能执行(找不到main方法)
    + 去[]：能通过编译，不能执行(找不到main方法)
6. 将main形参中的方括号换成...（三个小数点），程序能否编译和执行？
    + 可以通过编译，能正常执行

#### （二）查看Java发展历史
   附上一个链接，写的很全面
   [Java发展历史](https://blog.csdn.net/DJY1992/article/details/56666725)  
   [Java官方文档](https://www.oracle.com/technetwork/cn/java/javase/documentation/index.html)

#### （三）JDK、JRE和JVM的关系
1. JDK(Java Development Kit):
	是Java程序开发工具包，包含JRE和开发者用的工具。
	可以运行也可以开发Java程序
2. JRE(Java Runtime Enviroment):
	是Java程序的运行环境，包含JVM标准实现和运行时所需的核心类库。
	可以运行Java程序
3. JVM(Java Virtual Machine):
	Java虚拟机，是运行所有Java程序的假想计算机，是Java程序的运行环境。
	Java的虚拟机本身不具有跨平台的性能，每个操作系统下有专属的JVM。
	所有编写的Java程序都运行在JVM上,可将.class文件解释为机器码（...\jdk\jre\bin\java.exe）
  > JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。
  ```java
  疑问：JDK目录下有bin、lib、jre文件夹，而其中的jre文件夹下又有bin、lib----有什么不同？
  答：
    1. jdk是开发时环境，jre是运行时环境。就是编写java文件用jdk，运行java文件用jre；
    2. jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac
  ```

#### （四）Java程序的执行过程
1. 编写Java文件，得到.java文件(文本文件)
2. 编译器编译，得到.class文件(字节码文件)
3. 解释器将字节码文件编译为特定平台下的机器码
4. 操作系统运行机器码得到运行结果
> javac编译`.java文件`生成`.class文件`，Java翻译成对应操作系统(OS)机器码，操作系统执行机器码

#### （五）Java平台的划分
- [参考博客](https://blog.csdn.net/qq_36243386/article/details/85056070)
1. JavaSE Java Standard Edition Java 标准版
2. JavaME Java Micro Edition Java 微型版
3. JavaEE Java Enterprise Edition Java 企业版

#### （六）Java语言有哪些特点？
1. 面向对象，支持继承，封装和多态；除简单的变量类型外，绝大多部分成员都是对象。
2. 可移植，一次编译可在不同平台上解释执行
3. 安全性，无指针，有类装载器，字节码校验器，安全管理器等保证Java的安全
4. 并发性，支持多线程并行机制，分布式应用程序

#### （七）C/C++/Java的区别？
- [Java语言特性](https://baijiahao.baidu.com/s?id=1591559918900661165)
1. 语言：C纯面向过程语言；C++可面向过程可面向对象，是一门过渡语言；Java是面向对象的一门语言；
2. 运行：C/C++ 编译成本地机器码, 可以由操作系统直接运行，效率高；Java编译为字节码，由JVM去解释运行，效率低；
3. 指针：C/C++保留指针，程序员可以直接获取使用内存地址，Java出于安全性考虑，去掉指针;
4. 垃圾回收：C/C++程序员自己回收，手动管理；Java有自动回收机制;
5. 用途：C/C++效率高，适合做底层开发，如操作系统；Java安全性好跨平台,适合做大型软件，APP；


## 第二节：如何设计和使用类
### 一、设计类
- [x] 任务1：设计教务系统中的学生类
> UML：(Unified Modeling Language)统一建模语言
  - 使用UML工具：SoftwareIdeasModeler
  - 包含属性和方法
  -  先设计，在开发
1. 类（类型缩写） class
- 类名
- 属性（Attribute）
- 方法 (Operation) ---函数、操作
2. 对象（类的一个实体：实例化一个对象）---万物皆对象

### 二、类的创建与使用
1. 对象如何创建？ new 构造方法
```java
  Person person = new Person();
```
2. OOP编程主线
    类---创建对象---对象.方法、属性
3. 什么构造方法
- 名字和类名相同
- 无返回值类型
```java
  class Person {
      public void Person() {
        ....
      }
  }
  // 以上不是构造方法，构造方法没有返回类型（Void 也算是返回类型）
```
4. 默认构造方法
- 我们在创建一个类的时候，可以不明确提供构造方法，JVM会给自动添加构造方法
- 如果提供了构造方法，则JVM不会再自动创建构造方法
```java
// 默认构造方法
Person() {

}
```
5. 构造方法的作用是什么？
- 与new配合，创建对象---分配内存空间
- 初始化对象属性默认值
6. 能不能用对象调用构造方法？（不能）

7. private修饰的属性，只能在本类中

- [x] 任务3 如何在别的类中使用Student类的访问类型为private的属性？（封装）
1. 封装的目的：保护数据
2. 如何实现：属性私有，提供公共方法使用属性

属性的默认值问题
- 对象默认：null
- 整数默认：0
- 浮点型默认：0.0
- 字符型默认0
- 布尔型默认false
```java
  String name = "tit";//显示赋值
  int age;//默认赋值
  /*
  鄙视题：属性值的变化过程
  1. 默认赋值
  2. 显示赋值
  3. 构造方法赋值
  4. set()方法
  */
  String name = "tit";
  new Student("nuc");
  //name值变化过程：null---tit---nuc
```

- [x] 课内任务：写一个类，Teacher,提供属性age和name, 对age和name赋值，并输出他们的值，其中age的范围是20~150；
要求：有规范的JavaDoc注释，并生成。


## 第三节：数据类型和变量
[【参考：Oracle-java官网】](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)

### 一、数据类型有哪些？ （11种）
-  基本数据类型/（简单数据类型）  8种
-  引用数据类型/（复合数据类型）  3种

#### （一）基本数据类型（8种）
1. byte（1字节，8位，-128~127）
```java
  byte age = 200;//error：超出范围
```
2. short（2字节，16位，-32768~32767）
3. int（4字节，32位，-2^31 ~ 2^31-1）
4. long（8字节，64位，-2^63 ~ 2^63-1）
```java
  //笔试题：long类型数L、l可有可无（错）
  long salary = 2147483647;
  long salary = 2147483648;//error
  long salary = 2147483648L;//超过int表示的范围后必须要加"L"

  /*
  注：
    当值小于等于int类型最大值，可不加L,否则必须
    不建议使用小写"l"
  */
```
5. char (2字节，16位，0~65565)
```java
  char sex = '男';//right
  char sex = "男";//error
  char sex = 97;//right
  char sex = '\u0097'//right:Unicode编码

  /*
  注：
    字符型数据本质就是数字
    字符型用单引号
    Java语言采用Unicode编码，一个字符就是两个字节
  */
```
- [ ] 不同类型编码：ASCII ,ISO8859-1,GB2312,GBK,Unicode,UTF-8（*详细见Task/README.md*）
    链接：https://blog.csdn.net/Fly_1213/article/details/85249201
- [ ] 转义字符：转义就是失去特殊含义
      （  所有的ASCII码都可用"\\"加数字（一般是8进制数字）来表示。而C语言中定义了一些字母前加"\\"来表示常见的那些不能显示的ASCII字符如\0,\t,\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。）


 |转义字符|意义|ASCII码值（十进制）
 | :--:| :--:|:--:|
 |\n| 换行(LF) ，将当前位置移到下一行开头|010
 |\t| 水平制表(HT) （跳到下一个TAB位置）| 009
 |\r| 回车(CR) ，将当前位置移到本行开头| 013
 |\ \\| 代表一个反斜线字符'\\' |092
 |\\"|代表一个双引号字符|034
 |\\?|	代表一个问号|	063
 |\0|空字符(NUL)|000
 |\a|响铃(BEL)|007
 |\b|退格(BS) ，将当前位置移到前一列|008
 |\f|换页(FF)，将当前位置移到下页开头|012

```java
  //打印双引号
  System.out.println("\"\"");
  //打印两个反斜杠"\\"
```
6. float（4字节，32位，……）
```java
  flout height = 1.75;//error:必须加f/F
  flout height = 1.75F;//right
  float height = .8;//right:0.8
  float height = 8.;//right:8.0
  /*
    注：
      float类型数据"F"/"f"不能省去
  */
```
7. double (8字节，64位，……）
8. boolean 取值：true和false。长度不明确
```java
  boolean a = 1;//error:只能是True或False
```
##### 小结：
- 整数默认int,小数默认double
- Java长度由小变大
```java
  byte---short---int---long---float---double
  //长度不会随平台变化
```
- 数据类型可以转换（从低级类型到高级类型）
```java
/*
  规则：低级给高级自动转换，高级给低级强制转换
	排序：byte---short---int---long---float---double
	补充：char可直接转换int,boolean不参加转换
*/
  int num1 = 1;
  double num2 = 2;
  //从低级类型到高级类型
  num2 = num1;//right：自动转换
  //从高级类型转到低级类型
  num1 = num2;//error:需要强制转换
  uum1 = (int)num2;//right
  /*
  注：
    char与short都是16bit，在Java中，char是16bit长的无符号整数，因此范围是：0～65535，而short则是16bit长的带符号整数，范围是-32768～32767。 所以，两者虽然字长相同，但意义却不一样（表示范围并不完全重合或包含），因此不管是char转换成short，还是short转换成char，都属于数值的“窄化转换”（Narrowing Primitive Conversion）。 窄化转化都可能“丢失精度”，因此必须强制转换。
  */
```
#### （二）复合数据类型（引用数据类型）
- 复合(引用)类型（3种）：
类、数组、接口
- 引用类型就是类或接口类型
`String name;  Address addr;`
- 每个类就是一种类型，因此java中的类型可以引申为无限多种类型
`Person p;`
- java中每个变量都有确定的类型
`int age;   Student s;`

### 二、Java值传递
- 方法调用时，实参传给形参
- 传递的参数可以是：基本类型、引用类型
- Java中只有值传递
- 注意堆区和栈区的数据变化（画图）
- 可通过DeBug调试查看变量值

>Eclipse之DeBug调试
>1. 设置断点
>2. 进入子方法（Step Into/F5）
>3. 单步执行（Step Over/F6）
>4. 从子方法跳出（Step Return F7）---结合F5使用
>5. 结束调试---点击红色按钮
>6. 回到编辑模式---点击eclipse右上角图标（java）

### 三、面试问题
1. 什么是标识符？命名规则是什么？
- 标识符(identifier)就是名字
- 以"_"、"\$”、字母开头，后面加字母、数字、下划线、$
```java
  //以下哪些是合法的标识符？BCDE
  A. Hello World   B.True   C.String   D.学生  E._  F.*P  G.12abc  J.A@B
```
2. 什么是关键字（保留字）？有什么特点？
- [关键字-官网](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)
- 被Java语言保留，有特殊含义，标识符不能用
- 关键字全小写
- true、false、null 不是关键字（参考官网）
- goto、const是关键字，但不能使用
- system不是关键字
```java
  //面试题： 以下哪些是Java语言关键字？ab de(官方文档不在关键字列表中)
  A. goto  B. const C. NULL D. true E. false F. System
```
3. 局部变量和成员变量的区别
- 成员变量就是属性
- 局部变量在方法内部定义
- 局部变量没有默认值，使用前必须先赋值
- 区别方法：看定义的位置
- 开发中成员变量和局部变量名字不要相同
4. 内存逻辑的划分
  - 栈：先进后出,存放所有局部变量，由操作系统管理，用于数据交换
  - 堆：存放new关键字创建的对象
  - 全局数据区：存放全局变量
  - 方法区：存放程序代码
5. 什么是Java中的垃圾回收机制？（*详细见Task/README.md*）
- [图解Java 垃圾回收机制](https://blog.csdn.net/justloveyou_/article/details/71216049)
- 垃圾：废弃/无用的对象
- Java中采取自动的垃圾回收机制(garbage collection，GC)---有延时
- 内存泄漏：指废弃的对象没有被及时的回收
- 垃圾回收机制是JVM自带的一个线程（伴随主程序运行着的程序），用于回收废弃的对象
- 目的：减轻程序员的负担，减少了内存泄漏
- 我们能不能通过调用System.gc()强制回收？（不能，仅仅是建议JVM马上调用GC进行垃圾回收）
- [ ] finalize()方法有什么用？----【tip:搜索】（*详细见Task/README.md*）

> 内存泄漏：（Memory Leak）是指程序中己动态分配的堆内存由
于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程
序运行速度减慢甚至系统崩溃等严重后果。

6. Java中是否有可能存在代码泄露？
- 不可避免
- 当长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。
7. String 是不是内置的数据类型？
- 不是，是Java API中的一个类

### 四、补充
####（一）不同类型编码：ASCII ,ISO8859-1,GB2312,GBK,Unicode,UTF-8
[参考连接](https://blog.csdn.net/Fly_1213/article/details/85249201)
- **ASCII**：计算机最初是由美国等国家发明的，所以最初的字符编码规范是以英文为基础。录入英文字符编码标准：ASCII(American Stardard Code for Information InterChange 美国信息互换标准代码)，单字节编码，使用单字节8位 前127个存储英文字母及标点符号。

- **ISO8859-1 / Latin-1** ：ISO(国际标准化组织)在ASCII基础上做的扩展，向下兼容ASCII，也是单字节编码，是许多欧洲国家使用的编码标准。

- **GB2312** ：随着发展，各国都需要使用各国的语言使用计算机，相应的，我国大陆地区采用双字节 高低位字节的方式，存储简体中文。当存储中文字符时，高低位都存放大于127的数字，当读取高位字节时，若大于127，则认为是中文字符，将读取双字节进行识别，若小于127，则认为是英文字符，单字节识别。另外，GB2312在大于127位的编码库也提供了中文符号的编码，故英文标点符号称做半角符号，中文标点符号称作全角符号。

- **GBK** ：对GB2312的拓展，双字节编码，区别是当存储中文字符时，高位存放大于127的数字，低位不再是大于127的数字，将127之前的数字也囊括了。GBK将繁体中文也囊括进来。

- **Unicode** ：针对各个国家都使用不同的编码机制，iso(国际标准化组织)又站了出来，对全球编码做了整个的囊括，推出了Unicode ，但其字符集也是最复杂、占用空间最大的。
  Unicode，定长双字节编码，对ASCII采取高位补零的方式拓展，不兼容iso8859-1编码。
  说明： 定长编码便于计算机处理（GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java。

- **UTF-8** ：由于Unicode是一组编码映射，即一个字符映射一个16进制数字的形式。随着互联网发展，unicode不便于传输和存储，为了节省资源（无论是硬盘存储还是流量），相应的就产生了utf-8编码。
  UTF-8兼容ISO8859-1编码，同时也可以用来表示所有语言，不过UTF-8编码是不定长编码，一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节，比 unicode编码节省空间。

####（二）转义字符

|转义字符|意义|ASCII码值（十进制）
| :--:| :--:|:--:|
|\n| 换行(LF) ，将当前位置移到下一行开头|010
|\t| 水平制表(HT) （跳到下一个TAB位置）| 009
|\r| 回车(CR) ，将当前位置移到本行开头| 013
|\ \\| 代表一个反斜线字符'\\' |092
|\\"|代表一个双引号字符|034
|\\?|	代表一个问号|	063
|\0|空字符(NUL)|000
|\a|响铃(BEL)|007
|\b|退格(BS) ，将当前位置移到前一列|008
|\f|换页(FF)，将当前位置移到下页开头|012

####（三）什么是Java中的垃圾回收机制？
- [参考连接:垃圾回收机制](https://www.cnblogs.com/wabi87547568/p/5282892.html)
- [参考连接:图解Java 垃圾回收机制](https://blog.csdn.net/justloveyou_/article/details/71216049)
1. 垃圾回收机制（有延时）
    1）立即回收器(Garbage Collection ,GC)是JVM自带的一个线程（伴随主程序运行着的程序），用于回收废弃的对象;
    2）Java程序员不用亲自回收废弃对象，因为垃圾回收机制会自动进行回收;

2.  触发GC的条件
    1）GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用(存在延时)。但下面的条件例外。
    2）Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制调用GC线程。若GC一次之后仍不能满足内存分配，JVM会再进行两次GC，若仍无法满足要求，则JVM将报“out of memory”---内存泄漏的错误，Java应用将停止。
3. 两个重要方法
    1）System.gc()方法
使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：java -verbosegc classfile    由于这种方法会影响系统性能，不推荐使用，所以不详诉。
    2） finalize()方法
在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：protected void finalize() throws Throwable   在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。

> 之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。例如：
> 1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。
> 2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。

4. 减少GC开销的措施
    1)不要显式调用System.gc()。此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。大大的影响系统性能。  
    2)尽量减少临时对象的使用。临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。
    3)对象不用时最好显式置为Null。一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。
    4)尽量使用StringBuffer,而不用String来累加字符串。由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。  
    5)能用基本类型如Int,Long,就不用Integer,Long对象。基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。
    6)尽量少用静态对象变量。静态变量属于全局变量,不会被GC回收,它们会一直占用内存。
    7)分散对象创建或删除的时间。集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。

5. Java程序的内存泄漏问题（不可避免）
1）内存泄漏是指废弃的对象没有被及时的回收;
2）严重的内存泄漏会导致内存中的废弃对象越来越多，直到内存占满程序崩溃;
3）垃圾回收机制判断对象何时回收的依据是该对象是否还有变量在引用;
4）建议：确定一个引用变量的对象不在使用时，应该及时将引用类型变量设置为null;

####（四）java finalize方法总结，GC执行finalize的过程
- [参考：java finalize方法总结、GC执行finalize的过程](https://www.cnblogs.com/Smina/p/7189427.html)
1. finalize()方法定义在Object类中，所以所有类都继承了finalize()
2. 当应用程序或 Applet 退出时，调用每个对象的finalize() 方法
3. 调用时间：垃圾回收器在确定某对象没有被引用时(删除之前)，就对此对象调用方法
4. 主要用途：回收特殊渠道申请的内存，如非Java程序(C/C++)申请的内存
5. 不建议使用finalize(),如果用：尽量简单，且要避免对象再生


## 第四节：语句与运算符
### 一、运算符类型
- 算数运算符
    ```
      +   -   *   /   %     ++    --
    ```
- 比较（关系）运算符
    ```
        >   >=  <   <=  ==  !=
    ```
- 逻辑运算符
    ```  
        &&逻辑与(短路与)    ||逻辑或 (短路或)     ！逻辑非
        &与                |或  
    ```
- 位运算符
    ```java
     >>    <<    >>>     ~     ^      &    |
     3 >> 2  //00000011    把左边二进制数字向右移动两位，高位补 符号位
     3 << 2  //00001100    把左边二进制数字向左移动两位， 低位一律补零
     1011 0100 >>> 3       高位一律补零，无符号位右移
    面试题$$$：
    short x = 10;
    x = x + 1;  //×, 1是int型，x是short型，运算就高不就低，计算得到int型，而等号左边为short型

    short x = 10;
    x += 1;     //√，不会报错，可以理解为没有经过内存的转化，直接完成赋值操作

    &       同时为真才为真
    |       一者为真就为真
    ^       相同为假不同为真    (相同数字做^运算结果为0)
    ~       按位取反
    <<      左移运算符，低位一律补零
    >>      右移运算符，高位补符号位
    >>>     右移补零运算符，高位一律补零
    ```
-  赋值运算符
    ```java
    =   扩展的赋值运算符：+=  -=  *=
    面试题：
    short x =9;
    x = x + 1; //error 1为int型,开辟新的内存,存在类型转换

    short x = 9；
    x += 100; //理解为：x = x + 100;但没有开辟新内存
    ```

### 二、包
> API(application program interface) :就是类库
1. 使用包的目的：多人开发，不同人不同包，防止类名冲突
2. 报名命名规则：域名倒写+系统名+模块名+层次名。（包名全小写）
  ```java
  cn.edu.tit.jobtrace.student.vo
  cn.edu.tit.jobtrace.student.dao
  cn.edu.tit.jobtrace.student.service
  ```
3. 导入包
```java
import java.util.Scanner;//导入指定类
import java.util.*;//导入所有的类（不推荐）
```
> java.lang 包不需要导入（自动导入的），其余包都要导；

常用的包
- java.io---java输入输出包（文件读写）
- java.lang---java语言的核心包
- java.lang.reflect---反射相关包
- java.util---java实用包
- java.math---
- java.sql---
- java.text
4. 分类
- java基础包:以java开头
- java扩展包：以javax开头
- 第三方包：以org、com等开头
- 自定义包
5. 导包次序：java基础包->java扩展包->第三方包->自定义包

### 三、面试问题
1. if语句后面如果是定义语句，必须加花括号
    ```java
    //right
    if (5 > 0)
      System.out.println("hello");

    //error
    if (5 > 0)
      int a = 5;

    //right
    if (5 > 0) {
      int a = 5;
    }
    ```
2. 结束整个循环有几种方式
    ```java
      break;//只能跳出循环
      return;//程序不在向下执行
      system.exit();//直接退出程序
    ```
3. 双重循环效率问题
    ```java
    for (size_t i = 0; i < 5; i++)
    {
      for (int j = 0; j < 3; j++)
      {

      }
    }
    //比上面效率高
    for (size_t i = 0; i < 3; i++)
    {
      for (int j = 0; j < 5; j++)
      {

      }
    }
    ```
4. 扩展的赋值运算符号特点
    ```java
    //byte、char、shorrt类型在运算的时候自动变成int或者说JVM把他们以int考虑，只要不超范围就可以；
    short s = 20;//reght
    byte x = 100;//right
    s = s + 10;//error右侧是高级类型，赋值给低级类型需要强制转换
    s += 10;//right，
    ```

5. 1-0.9的结果？
- 不是0.1，接近0.1
- 十进制和二进制转化在浮点数运算上存在精度丢失
  ```java
  System.out.println("1-0.9 = "+(1-0.9));
  System.out.println("1-0.8 = "+(1-0.8));
  System.out.println("1-0.7 = "+(1-0.7));
  System.out.println("1-0.6 = "+(1-0.6));
  System.out.println("1-0.5 = "+(1-0.5));
  System.out.println("1-0.4 = "+(1-0.4));
  System.out.println("1-0.3 = "+(1-0.3));
  System.out.println("1-0.2 = "+(1-0.2));
  System.out.println("1-0.1 = "+(1-0.1));
  ```
6. switch语句
    ```java
    switch(n)
    {
    case 1:
      执行代码块 1
      break;
    case 2:
      执行代码块 2
      break;
    default:
      n 与 case 1 和 case 2 不同时执行的代码
    }
    ```
  - switch语句中可以检测的类型：int、short、char、String、enum
  - 不能检测的数据类型为：long、boolean、浮点型（double、float）
  - default可有可无，且位置在哪不受影响。


## 第五节：面向对象特性
1. 封装
2. 继承
3. 多态
4. 抽象
> 封装的目的：保护数据
>继承的目的：类的复用
>多态的目的：增强程序的复用性，解耦。
>抽象的目的：被子类继承，实现类的复用

### 一、访问控制
> 访问控制：控制类外面可以访问类中的那些属性和方法；
1. 访问控制符号：用于修饰属性和方法/（类）

    |修饰符|本类内部|同包中的类|子类|包外其它类
    |:--:|:--:|:--:|:--:|:--:|
    |public|可以访问|可以访问|可以访问|可以访问
    |protected|可以访问|可以访问|可以访问|不能访问
    |默认|可以访问| 可以访问|不能访问|不能访问
    |private|可以访问|不能访问|不能访问|不能访问

2. 访问控制符修饰类：
- 对于类的修饰可以使用public和默认（default）方式；
- public修饰的类可以被任何一个类使用；
- 默认的访问控制的类只能被同包中的类使用；



### 二、封装
1. 什么是封装：就是将数据和对数据的操作集中的定义在对象中，外界仅能通过对象提供的接口访问对象的属性和功能;
    -  属性私有(private)
    -  提供公共方法访问(public)
3. 封装的意义：对外提供可调用的、稳定的功能；
4. 封装内部具体的实现细节，外界不可访问，这样的好处在于：降低出错的可能性；
5. 内部变化，不会影响外部使用；

### 三、继承
1. 什么是继承：类的复用---即使用现有类的定义复制并扩展出另一个新的类定义，子类可以继承父类中的成员变量和成员方法(不包含构造)，同时也可以定义自己的成员变量和成员方法；
    > 泛化：从多个类中，抽取相同部分，生成父类的过程叫做泛化；
    >设计时，从子类泛化出公共父类，再让子类继承父类；    


2. Java语言不支持多重继承，一个类只能继承一个父类，但一个父类可以有多个子类；
 - 面试题：一个类只能有一个父类？不一定---A->B->C
3. 继承的语法规则？extends
    ```java
    Class Person {
      //...
    }
    Class Student extends Person {
      //...
    }
    ```
4. 继承要求：取决于父类的访问控制符
- 同一包中继承：子类可以访问父类访问控制符为：public、protected、以及默认（default）的属性即方法；
- 跨包继承：默认情况下，只要不在一个包内，即使是继承也无法访问父类的默认访问控制的属性及其方法
  - 类中访问：
  若子类需要访问父类属性或方法：要求父类属性及方法访问权限最低要是protected（public、protected）;
  - 类外访问：
  子类对象只能直接访问子类从父类继承的访问控制符为【public】的属性或方法；
若子类需要访问父类中protected修饰的方法：子类需要使用重写通过super来调用父类的方法；
(java中规定：子类重写父类的方法，子类的方法访问控制范围不能小于父类方法的访问控制范围)
5. 继承关系下，父类的构造方法调用问题？
- 创建子类对象的时候，父类的默认构造方法会默认调用
- 父类没有构造方法时，子类的构造函数需要使用super()指定父类的构造方法
- super()必须放在子类构造方法的第一行
6. 对象的构造次序如何？
- 继承关系是自下而上---子类继承于父类
- 构造函数调用是自上而下---先完成父类的构造，再完成子类的构造

7. 方法的重写（Override）：
- 原因：继承于父类的方法无法满足子类的需要
- 方法名、参数列表（数据类型、个数、次序）、返回值类型相同，访问控制相同或者更加宽泛
- 父类构造方法不能被继承，所以不能被重写
  > @Override : 断言机制。就是告诉编译器当前方法是重写父类方法，
  >请编译器协助检查方法签名，如果重写的方法签名在父类中没有找到，则编译错误；

8. 方法的重载（Overload）：一个类中有多个同名方法
- 规则：方法名字相同，参数列表必须不同，返回值和访问控制符不限
- 构造方法可以重载

9. this的使用：
- this表示当前类的对象
- 使用this()调用本类自己的构造方法
- this.(属性/方法),调用本类的属性和一般方法
10. shper的使用：
- super表示父类的对象
- 使用super()调用父类的构造方法
- 使用super.(属性/方法)，在子类中调用父类的属性和一般方法
>this()和supr()不能同时调用，都需要放在构造方法体的首行

12. 创建子类对象时，程序执行过程?
- 父子类当中只有无参构造方法：先执行父类构造后执行子类构造
- 父类子类中属性赋值动作，赋值也是先赋值完父类的属性值，再赋值子类的属性， 代码执行时先给属性赋值，再执行方法。
- 父子类有游离块：看代码位置
>属性赋值顺序：隐式初值-->显示赋值-->构造赋值

13. **父类的引用指向子类的对象**
- 父类的引用可以指向子类的对象，但通过父类的引用只能访问父类自己定义的属性和功能部分（包含子类重写父类的方法），不能访问子类扩展的部分（独有的属性和功能）
- 例如Person类型的对象，就无法访问子类Student的成绩这个属性
14. 动态方法调度
- 在运行时，父类变量根据指向子类对象的不同，动态判断调用何种重写方法
  ```java
  /*动态方法调度*/
  Person dad = null;
  Child1 = son1 = new Child1();
  Child2 = son2 = new Child2();

  //爸爸和大儿子一起做蛋炒饭
  dad = son1;
  dad.cook;

  //爸爸和二儿子一起包饺子
  dad = son2;
  dad.cook;
  ```
15. 笔试题（重写和重载的区别&&父类的引用指向子类的对象）
    ```java
    //下面代码输出结果是？
    class Super {
        public void f() {
            System.out.println("super.f()");
        }
    }

    class Sub extends Super {
        public void f() {
            System.out.println("sub.f()");
        }
    }

    class Goo {
        public void g(Super obj) {
            System.out.println("g(Super)");
            obj.f();
        }

        public void g(Sub obj) {
            System.out.println("g(Sub)");
        }
    }
    class Test{
        public static void main(String[] args) {
            Super obj = new Sub();
            Goo goo = new Goo();
            goo.g(obj);
        }
    }

    //结果
    g(Super)
    sub.f()
    /*
    注意：如果父类Super中没有f()方法，那么这道题的输出结果就是编译错误；
    原因是：父类中没有f()方法，子类中的f()方法就不是重写，所以父类定义的引用变量obj就不能访问子类的成员方法/（非重写方法）！
    */
    ```

### 四、抽象
1. 抽象类、抽象方法
- 抽象类就是仅定义所有子类共享的形式，而没有定义具体实现细节的父类
- 抽象类中，那些只有方法的定义，没有实现细节(没有方法体)的方法叫做抽象方法；
- 一个类中如果包含抽象方法，该类应用abstract关键字声明为抽象类；
- 如果一个类继承了抽象类，必须重写其抽象方法（除非该类也声明为抽象类），且不同的子类可以有不同的实现。
- 语法：（被`abstract`修饰）
  ```java
  // 抽象类
  public abstract class 类名 {
      // class boby

      // 抽象方法
      访问修饰符 abstract 返回值类型 方法名();
  }
  ```

2. 抽象类不能实例化
- 抽象类不可以实例化，因为抽象类是不完整的，要想使用抽象类中的普通方法，只能通过子类对象继承后调用；
  ```java
  Father father =  new Father();//编译错误
  ```
- 另外，即使一个类中没有抽象方法，也可以使用abstract修饰类。作用就是不让该类实例化；
- abstract VS final
    □ 抽象类：天生就用来被继承！不继承，就没有任何意义。
    □ final：专门用来禁止被继承！和抽象类的意义刚好相反！


>高内聚低耦合:在一个模块内部
> 23中设计模式*********************************************

### 五、接口
#### （一）定义一个接口
1. 接口是一个标准
2. 接口是引用类型之一；（类、数组、接口）
3. 接口的作用是：解耦，降低耦合,便于维护。
4. 接口是一组方法定义的集合，但所有方法没有实现(默认)；
> JDK1.8之后，接口中的方法可以有方法体（被default,static修饰的方法）
> [链接](https://blog.csdn.net/gkmmg/article/details/79656267)
5. 接口天生用来被继承，不能被实例化；
6. 语法：
    ```java
    public interface 接口名{
        public abstract 返回值类型 方法名()；
    }
    //public abstract 可以省略，编译器会自动补全；
    ```

#### （二）实现一个接口
1. 一个类可以通过implements关键字“实现”接口，称为：实现类；
2. 语法：
    ```java
    public class 实现类类名 implements 接口名{
        //class boby
    }
    ```

3. 一个类要实现某个接口，就必须实现该接口中定义的所有抽象方法；
4. 因为接口中的方法都是public修饰的，所以子类实现接口的方法时，也必须显示定义public访问修饰；
5. 实现类可以实现多个接口，该类需要实现所有接口中定义的所有方法；；

#### （三）接口的继承
1. 接口间可以存在继承关系，一个接口可以通过extends关键字继承另外一个接口。子接口继承了父接口中定义的所有方法。
2. 接口支持多继承，一个接口可继承多个接口；

#### （四）继承父类与实现接口
1. 一个普通的类可以继承一个类的同时再实现若干接口。
2. 语法：(强调先继承（extends）再实现接口（implements）,不能颠倒！)
    ```java
    public class 子类名 extends 父类名 implements 接口 {
        // class body
    }
    ```
#### （五）动态调用接口方法
1. 接口可以作为一种特殊类型声明一个引用类型的变量。
    ```java
    IUnionPay atm;//编译正确
    ```
2. 一个接口类型的变量可以引用实现了该接口的类的对象。
    因为可以动态调度，所以可以使用接口类型引用实现类的变量；
    ```java
    IUnionPay atm = newATMCBC();
    IUnionPay atm = new ATMABC();
    ```

3. 通过接口类型变量仅能调用实现该接口的类中重写的方法。
    ```java
    atm.drawMoney(3000);//本质，父类型的引用，可以调用子类型重载的方法；
    atm.takePic();//编译错误：因为是子类重写别的接口的方法,不是重写当前IUnionPay接口的，所以不能调用。
    ```
#### （六）接口中定义常量
1. 接口中除了抽象方法外，只能定义“常量”。
2. 编译器会自动增加public static final 修饰。
3. 何时在接口中定义常量：一般用于实现类中引用固定的备选项。
4. 比如：银联规定只能支持CBC,ABC两家银行的银行卡，不支持其它银行的银行卡。
5. 在接口中定义常量，必须声明的同时初始化。


#### （七）接口和抽象类的异同点：
1. 相同点
- 天生都是被继承的。不能实例化对象
- 一个类无论是实现接口还是继承抽象类，都必须实现其中所有的抽象方法。
- 接口和抽象类都可以声明父类型的变量，引用子类型对象
- 父类型对象的引用都可以调用子类型对象中重写的方法
> 切记：父类型对象的引用都不能调用子类型对象中非重写的方法
- 因为以上两点，所以抽象类和接口，都可以实现动态创建对象，和动态方法调度

2.不同点
- 抽象类不允许多继承，而接口可以多继承
- 使用场景不同：
抽象类：主要用于封装子类中共享的成员。只有个别方法自己不能实现，才能定义抽象方法，请子类自力更生自己实现
接口：主要用于在程序中定义标准。接口完全不实现任何方法
- 成员的修饰词不同
抽象类中的成员，可以使用任何关键字修饰
接口中的成员变量都是public static final 的，方法都是public abstract的

#### （八）面试题
1. 抽象类能否实现接口？
可以。
2. 接口能实现接口吗？
不能。
3. 一个类一定是先继承父类，在实现接口


### 六、多态
1. 什么是多态：对象的多种形态，一个对象被多种称谓
2. 表现方面：
- 引用多态（继承或接口实现）
  ```java
  // 父类的引用可以指向本类的对象；
  Animal obj1 = new Animal();
  // 父类的引用可以指向子类的对象；
  Animal obj2 = new Dog();  
  ```
  >这里我们必须深刻理解引用多态的意义，才能更好记忆这种多态的特性。为什么子类的引用不能用来指向父类的对象呢？通俗的讲：就以上面的例子来说，我们能说“狗是一种动物”，但是不能说“动物是一种狗”，狗和动物是父类和子类的继承关系，它们的从属是不能颠倒的。当父类的引用指向子类的对象时，该对象将只是看成一种特殊的父类（里面有重写的方法和属性），反之，一个子类的引用来指向父类的对象是不可行的！！
- 方法多态
根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。
（1）创建本类对象时，调用的方法为本类方法；
（2）创建子类对象时，调用的方法为子类重写的方法或者继承的方法；
（3）使用多态的时候要注意：如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！
**注意： 继承（包括接口的实现）是多态的基础。**

3. 多态中方法调用和执行
- 编译时，方法调用看变量：父类引用指向不同的子类对象，所调用的方法随子类变化而变化。
- 运行时，方法执行看对象：如果一个子类型的对象，向上造型为父类型的变量时，向上造型为不同父类型变量可用的功能也是不一样的。

4. 为什么使用多态？(增强代码的复用能力)
    ```java
    class Person {
        int age;

        public Person(int age) {
            super();
            this.age = age;
        }

        public int getAge() {
            return age;
        }
    }

    public class Student extends Person {

        public Student(int age) {
            super(age);
        }

        public void learn() {
            System.out.println("好好学习,天天向上!");
        }
    }

    class Teacher extends Person {

        public Teacher(int age) {
            super(age);
        }

        public void teach() {
            System.out.println("好好教书！");
        }
    }

    class CalcBirthYear {
        public int CalcYear(Person person) {
            return 2019 - person.getAge();
        }
    }

    class Test {
        public static void main(String[] args) {
            Student student = new Student(20);
            Teacher teacher = new Teacher(30);

            CalcBirthYear calcBirthYear = new CalcBirthYear();
            int syear = calcBirthYear.CalcYear(student);
            int tyear = calcBirthYear.CalcYear(teacher);
            System.out.println("学生出生年：" + syear);
            System.out.println("老师出生年：" + tyear);
        }
    }
    ```

### 七、引用类型转换
1. 向上类型转换(隐式/自动类型转换，小类型转换为大类型)
- 父类应用指向子类对象时就是向上类型转换
  ```java
  Dog dog = new Dog();
  Animal animal = dog;// 自动类型提升，向上类型转换
  ```
2. 向下类型转换(强制类型转换，大类型转换为小类型)
- 将上述代码再加上一行，我们再次将父类转换为子类引用，那么会出现错误，编译器不允许我们直接这么做，虽然我们知道这个父类引用指向的就是子类对象，但是编译器认为这种转换是存在风险的。如：
  ```java
  Dog dog = new Dog();
  Animal animal = dog;// 自动类型提升，向上类型转换
  Dog dog2 = animal;// 编译报错
  ```
- 我们可以通过强制类型转换。如：
  ```java
  Dog dog = new Dog();
  Animal animal = dog;// 自动类型提升，向上类型转换
  Dog dog2 = (Dog)animal;// 向下类型转换，强制类型转换
  ```
- 但是如果父类引用没有指向该子类的对象，则不能向下类型转换，虽然编译器不会报错，但是运行的时候程序会出错，如：
  ```java
  Dog dog = (Dog)new Animal();// 编译无错，执行报错！
  // 其实这就是上面所说的子类的引用指向父类的对象，而强制转换类型也不能转换！！
  ```
- 还有一种情况是父类的引用指向其他子类的对象，则不能通过强制转为该子类的对象。如：
  ```java
  Dog dog = new Dog();
  Animal animal = dog;// 自动类型提升，向上类型转换
  Dog dog2 = (Dog)animal;// 向下类型转换，强制类型转换
  Cat cat = (Cat)animal;// 编译无错，执行报错！
  ```
  >这是因为我们在编译的时候进行了强制类型转换，编译时的类型是我们强制转换的类型，所以编译器不会报错，而当我们运行的时候，程序给animal开辟的是Dog类型的内存空间，这与Cat类型内存空间不匹配，所以无法正常转换。这两种情况出错的本质是一样的，所以我们在使用强制类型转换的时候要特别注意这两种错误！！
- 下面有个更安全的方式来实现向下类型转换( instanceof运算符)。
  instanceof是Java的一个二元操作符，和==，>，<是同一类。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型数据。
  ```java
  /*
  1）在强制类型转换中，为了避免出现ClassCastException,可以通过instanceof关键字判断某个引用指向的对象是否为指定类型
  2）语法：对象 instanceof 目标类型
  3）返回值：
    - true:说明对象就是目标类型或者目标类型的小子类型，可以转换；
    - false:说明不满足强制转换前提，不能转换；  
  */

  //利用if语句和instanceof运算符来判断两个对象的类型是否一致。
  if(animal in instanceof Cat) {
    Cat cat = (Cat)animal;
  }
  ```
- 补充说明：在比较一个对象是否和另一个对象属于同一个类实例的时候，我们通常可以采用instanceof和getClass两种方法通过两者是否相等来判断，但是两者在判断上面是有差别的。Instanceof进行类型检查规则是:你属于该类吗？或者你属于该类的派生类吗？而通过getClass获得类型信息采用==来进行检查是否相等的操作是严格的判断,不会存在继承方面的考虑；
>总结：在写程序的时候，如果要进行类型转换，我们最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。

### 八、static与final
#### （一）final
- 修饰属性、方法、类
- 修改属性：值不能更改（常量）
- 修饰方法：方法不能重写（继承中子类不能重写父类中被final修饰的成员方法）
- 修饰类：类不能被继承
- 被final修饰的属性：要不显示赋值，要么构造方法赋值
  ```java
  //错误：final修饰的属性/变量不能被修改
  class Test {
    final int PI = 3.1415926;  
    public Test(int pi){
      this.PI = pi;
    }
  }
  ```
- 面试题：
  - 构造方法能不能被final修饰？（不允许）
  - final abstract能不能同时修饰一个类？（不能）

#### （二）static
- 修饰：属性、一般方法、游离块、内部类
- 不能修饰：外部类，局部变量、构造方法
- 面试题：能不能修饰外部类和局部变量？（不能）
- 修饰属性：静态属性/类变量
- 修饰方法：静态方法
- java里为什么主函数前面要加static修饰  [【参考连接】](https://blog.csdn.net/breaker892902/article/details/9331425)
- static修饰的成员变量不属于对象的数据结构
- static成员变量和类的信息放在一起，仅保留一份，用于共享，而不是在堆中保留在每个对象里的多个副本
- 被static修饰的属性和方法可以用类名字直接调用，可以不创建对象。不过，对象也可以直接调用
- 静态方法里不能使用非静态属性。（eg：main函数不能直接使用本类中的非静态的成员变量）
- static游离块在类加载的就被执行，且只执行一次
- [static参与的程序执行次序](https://my.oschina.net/u/3788721/blog/1628215)
  > 父类的静态
  > 子类的静态
  > 父类的非静态
  > 父类的构造
  > 子类的非静态
  > 子类的构造
- 类加载机制
  > .class字节码文件被JVM（Java虚拟机）加载
  > 堆 对象
  > 栈 局部变量
  > 全局数据区 static
  > 代码段
- 静态方法中不能使用super和this(它们实例化的对象)
- static方法的虚方法的调用有什么特点？
  > 虚方法调用对静态方法无效
  > 因为static方法不能被重写

- 面试题
  ```java
  class Test {
      // Test example = new Test();
      static Test example = new Test();

      public Test() {
          System.out.println("lalala");
      }

      public static void main(String[] args) {
          Test test = new Test();
      }
  }
  // 不加static修饰，程序就存在递归
  ```


## 第六节：设计模式
### 一、问题
1. 什么是设计模式
    一种通用方法和手段  
2. ：Java中有多少种模式（23种）
  - 共23种设计模式。
  - 参考资源：《Java与模式》、《Head First设计模式》、菜鸟教程
3. 问题三：设计模式什么场合会用？
    一般在框架里用，eg：spring框架
4. 列举几个Java设计模式
- 工厂模式 ***
- 单例模式 ***
- 适配器模式
- 装饰模式
- 模板方法模式
- 观察者模式
- MVC模式
> 单例模式和工厂模式一定能手写，脱离IDE。
> 方法：先画类图，再写代码。

### 二、OOP设计原则[（参考链接）](https://www.cnblogs.com/princessd8251/articles/3784949.html)
- OCP（Open-Closed Principle），开放封闭原则：软件实体应该扩展开放、修改封闭。
- DIP(Dependency Inversion Principle)，依赖倒置原则：摆脱面向过程编程思想中高层模块依赖于低层实现，抽象依赖于具体细节。OOP中要做到的是，高层模块不依赖于低层模块实现，二者都依赖于抽象；抽象不依赖于具体实现细节，细节依赖于抽象。。
- LSP(Liskov Substitution Principle)，Liskov替换原则：继承思想的基础。“只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才真正被复用，而衍生类也才能够在基类的基础上增加新的行为。”
- ISP（Interface Insolation Principle），接口隔离原则：接口功能单一，避免接口污染。
实现：一个类对另外一个类的依赖性应当是建立在最小的接口上的。使用多个专门的接口比使用单一的总接口要好。
- SRP(Single Resposibility Principle)，单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。 如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会抑止这个类完成其他职责的能力。
- CARP（Composite/Aggregate Reuse Principle），合成/聚合复用原则：设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。
实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。
- LoD(Law Of Demeter or Principle of Least Knowledge)，迪米特原则或最少知识原则：就是说一个对象应当对其他对象尽可能少的了解。即只直接与朋友通信，或者通过朋友与陌生人通信。

### 三、常用设计模式
#### （一）模板方法模式
 代码实现
- 写一个抽象类（模板类），有具体的方法
- 创建子类，重写父类的抽象方法

-  面向对象的设计原则
eg：开闭原则

#### （二）单例/单子模式（非常重要）
1.解决什么问题？
  一个类只能创建一个对象
2. 什么时候用？
    只需要单一对象的时候，比如一个宿舍只需要一个饮水机
3. 实现模式
- 饿汉式
（1）属性：private、static属性，当前类类型，立即初始化
（2）构造方法必须私有,private修饰
（3）创建get方法，public、static修饰，通过get方法获得当前类的对象（实例）
（4）特点：线程安全，效率高
  ```java
  public class Person {
      /**属性：private、static修饰，类型为当前类类型，且立即初始化 */
      private static Person person = new Person();

      /**
       * 构造方法必须私有
       */
      private Person() {
          System.out.println(" 这里是饿汉式的私有构造方法！");
      }

      /**
       * public、通过get当前类的对象
       * @return
       */
      public static Person getPerson() {
          return person;
      }
  }

  //测试类
  class TestPerson {
      public static void main(String[] args) {
          //static方法，直接通过类调用进行对象初始化
          Person person1 = Person.getPerson();
          Person person2 = Person.getPerson();

          //属于同一个对象
          System.out.println(person1 == person2);
      }

  ```
- 懒汉式
（1）属性：private、static修饰，类型为当前类类型，不初始化
（2）构造方法必须私有,private修饰
（3）创建get方法，public、static修饰，通过get方法获得当前类的对象（实例），首次获取需要实例化创建对象
（4）特点：线程不安全，效率低
（5）两者区别：对象创建的时间点不同，饿汉式早，懒汉式晚。饿汉是在属性上直接创建对象，懒汉式则是在方法调用的时候再创建对象。
  ```Java
  public class Student {
      /**属性：private、static修饰，类型为当前类类型，不先初始化，只先声明 */
      private static Student student;

      /**
       * 构造方法必须私有
       */
      private  Student() {
          System.out.println("这里是懒汉模式的私有构造方法！");
      }

       /**
       * public、通过get当前类的对象(首次使用需要实例化)
       * @return student
       */
      public static Student getStudentInstence() {
          if(student == null)
              student = new Student();
          return student;
      }  
  }

  //测试类
  class TestStudent {
      public static void main(String[] args) {
     		//static方法，直接通过类调用进行对象初始化
          Student stu1 = Student.getStudentInstence();
          Student stu2 = Student.getStudentInstence();

          //属于同一个对象
          System.out.println(stu1 == stu2);
      }
  }
  ```

#### （三）工厂模式
1. 什么是工厂模式？
    向用户屏蔽创建对象的细节，直接取对象即可。比如：我们取手机店买手机，不需要了解手机是如何生产的？

2. 最终目的：
    创建者和调用者的分离

3. 分类
- 简单工厂模式
- 工厂方法模式： 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法是一个类的实例化延迟到其子类。
- 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

4. 使用示例：
- Calendar的getInstance方法：Calendar.getInstance();
- JDBC中Connection对象的获取getConnection方  法:DriverManager.getConnection();

- spring中的IOC容器创建、管理bean对象的时候
- 反射中Class对象的newInstance方法
5. 代码实现
- 简单工厂模式（参见代码部分）
- 工厂方法模式（参见代码部分）


## 第七节：Java API的应用
### 一、基本介绍
#### （一）API
1. 什么是API
- API(Application Programming Interface)——应用程序编程接口

    > 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

2. API分类
- JDK带的
- SDK
- 第三方Apache
- 公司自己提供

#### （二）微服务 ***
1. 什么是微服务？
- 给我公开接口，我来调用
- 微：小
- 服务：一个功能或者一个系统
- 微服务：小型系统或功能

2. 微服务相关技术
1. Spring Boot
2. Spring Cloud

例：我开发的教务管理系统：教务管理、学历验证、支付、短信验证、学生户籍信息
- 教务管理：开发人员根据需求开发
- 学历验证：调用【学信网】 的接口
- 支付：调用【微信支付】的接口
- 短信验证码：调用【网易】的接口
- 学生户籍验证：调用【公安户籍管理】的接口

### 二、常用API
#### （一）String类
1. String类考题
- 面试题
列举几个常用的被final修饰的类
eg:String 、Math、System、Integer等
- 提示：String不是关键字；是不是Java的内置类型？不是。
int String = 90;//正确

2. String类的常用方法
> 多查看java jdk文档
- String(char[] value) //将字符数组转换成字符串
- String newName = new String(name.getBytes("ISO-8859-1"),"UTF-8");// 处理中文乱码
- boolean equals(Object anObject)  
- toCharArray();  //将字符串转化成数组
- boolean equals(Object anObject)  //区分大小的比价
- boolean equals(Object anObject)  //忽略大小写的比较
- string.trim();//去掉字符串的空格
- String substring(int beginIndex, int endIndex)  //截取子串
- String substring(int beginIndex)  //截取开始索引后的所有字符
  ```Java
  substring(2);//从索引开始，取到结束
  substring(1,1);//有结果，长度为0
  substring(4,2);//error
  ```
- String replace(char oldChar, char newChar)  //替换单个字符
- String replace(CharSequence target, CharSequence replacement)  //替换多个字符
- char charAt(int index)  //返回 char指定索引处的值



#### （二）StringBuilder类和StringBuffer类
- String和StringBuilder、StringBuffer区别是什么？
String是不可变字符串类（字符串值/内容不可变，字符串指向可以改变，貌似是一个常量），后者是可变字符串类
  ```Java
    String str = "chana";
    str.toUpperCase();//str还是小写
    String str2 = str.toUpperCase();//str2是大写
    //str2是大写，str没有改变，还是小写
  ```
- StringBuilder、StringBuffer是可变字符串类
 区别：StringBuffer线程安全的，StringBuilder线程是不安全的(但是效率高)
  ```java

  ```
- 开发中常用在SQl组合查询上，动态拼接SELECT语句；
- 常用函数
  ```java
    append();//追加
    delete();//删除
    insert();//插入
    reverse();//字符串按转
    replace();//字符串替换
    length();//字符串长度
    charAt();//指定索引的字符提取
    subString()//专辑顶索引范围字符提取
  ```

- 面试题:字符串的创建方式有哪些？有什么不同？--- 两种

    ```java
    String str1  = "china";
    String str2 = new String("china");//创建了几个对象？---2个第一个是:"china",第二个是str2指向的对象（也就是new出来的对象）
    String str3 = "china";
    ```
  - String存储机制---字符串池
#### （三）System类
- System.currentTimeMillis()//输出程序的执行时间（毫秒）
- System.nanoTime()//输出程序的执行时间（纳秒）
- arraycopy()//两数组内容替换
- exit()//终止JVM
- gc()//提醒JVM回收垃圾（无用的对象等）

#### （四）Math类
- Math.ceil()//相上取整
- Math.floor//向下取整
- Math.random()//产生一个随机[0,1)
- Math.round()//把一个数字舍入为最接近的整数
  ```java
    // 结果分析：负数-如果绝对值大于大于0.5，原数+0.5，结果向下取整（变小）
    System.out.println(Math.round(-11.2));//-11
    System.out.println(Math.round(-11.5));//-11 -11.5+0.5=11
    System.out.println(Math.round(-11.6));//-12
    System.out.println(Math.round(11.2));//11
    System.out.println(Math.round(11.5));//12
    System.out.println(Math.round(-0.5));//0
  ```

#### （五）Random类
java.util.Random 是Java随机数类
- 生成0`1000的随机数
  ```Java
  Random ran = new Random();
  int x = ran.next(1000);
  ```



#### （六）Date和Calendar类
```java
/**
 * 使用Date类获取当前日期时间
 *
 * @return 当前日期时间
 */
public static String getCurrentDate() {
    Date date = new Date();
    return date.toLocaleString();
}

/**
 * 使用Calendar类获取当前日期时间
 *
 * @return 当前日期时间
 */
public static String getCurrentDateByCalendar() {
    Calendar date = Calendar.getInstance();
    return "" + date.get(Calendar.YEAR) + "-" + (date.get(Calendar.MONTH) + 1) + "-"
            + date.get(Calendar.DAY_OF_MONTH) + " " + date.get(Calendar.HOUR_OF_DAY) + ":"
            + date.get(Calendar.MINUTE) + ":" + date.get(Calendar.SECOND);
}
```


#### （七）自定义jar包使用
- 导出包
  ```Java
  示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:
         jar cvf classes.jar Foo.class Bar.class
  示例 2: 使用现有的清单文件 'mymanifest' 并
             将 foo/ 目录中的所有文件归档到 'classes.jar' 中:
         jar cvfm classes.jar mymanifest -C foo/ .
  ```
- 导入jar包（Bulid Path）
- 调用jar包中函数

#### （八）Object类（顶级父类）
- 位于核心包里
- clone();
- equals();
- toString();
- finalize();

#### （九）封装类的使用
- Wrapper class
- 什么是封装类？
  8种基本数据类型对应的类，类型，就是封装类，由Jdk提供，位于Java.long中
  boolean---     Boolean
  byte---        Byte
  short---       Short
  char---        Character
  int---         Integer
  long---        Long
  float---       Float
  double---      Double


#### （十）BigDecimal类
- 实现1-0.9的精确计算
  ```java
      System.out.println(1-0.9);//0.099999999999
  ```
- 如何实现精确计算么？---使用java.math.BigDecimal
- 代码示例
  ``` java
  public class Calc {

      /**
       * 使用BigDecimal实现时间精确计算（但是依然无法计算出）
       *
       * @param num1 计算数字一
       * @param num2 计算数字二
       * @return 不精确计算结果
       */
      public double sub(double num1, double num2) {
          BigDecimal number1 = new BigDecimal(num1);// API参数为double类型
          BigDecimal number2 = new BigDecimal(num2);
          return number1.subtract(number2).doubleValue();
      }

      /**
       * 使用BigDecimal实现时间精确计算（结果正确）
       *
       * @param num1 计算数字一
       * @param num2 计算数字二
       * @return 精确计算结果
       */
      public double sub2(double num1, double num2) {
          BigDecimal number1 = new BigDecimal(num1 + "");// API参数为String类型
          BigDecimal number2 = new BigDecimal(num2 + "");
          return number1.subtract(number2).doubleValue();
      }

      /**
       * 主方法测试
       * @param args
       */
      public static void main(String[] args) {
          Calc calc = new Calc();
          double num1 = 1;
          double num2 = 0.9;
          // 参数为doule类型
          System.out.println(calc.sub(num1, num2));
          // 参数为String类型
          System.out.println(calc.sub2(num1, num2));
      }
  }
  ```


## 第八节：异常处理
### 一、问题引入：除法计算
- 不使用异常捕获
直接报错，程序终止
- 使用异常捕获（try-catch）
提示友好，程序还可继续执行（跳过try异常后代码）
### 二、异常处理机制如何？
首先：执行到异常时，JVM自动创建一个异常类对象，后面的代码不在执行。然后，catch捕获异常，执行catch中的代码。如果catch无法捕获异常，程序退出。
  > Exception 有很多一场子类

### 三、异常处理语法如何？
- try catch finally
  ```Java
  /**
   * 除法计算（添加异常捕获)
   * @param num1 被除数
   * @param num2 除数
   * @return 相除结果
   */
  public double div2(int num1, int num2) {
      double result = 0;
      try {
          //一旦出现异常，JVM直接创建ArithmeticException对象
          result = num1 / num2;
      } catch (Exception e) {
          System.out.println("数据不合法！");
          //e.printStackTrace();
      } finally {// 不管有无异常必定要执行，可选则添加，一般用于释放资源
          System.out.println("finally");
      }
      return result;
  }
  ```
- finally
  + 不管有无异常必定要执行
  + 可选则添加
  + 一般用于释放资源

### 四、手动抛出异常
- 什么时候用？根据编程者的需要，使用`throw`抛出异常
  ``` Java
  /**
   * 除法计算（手动添加异常捕获)
   *
   * @param num1 被除数
   * @param num2 除数
   * @return 相除结果
   */
  public double div3(int num1, int num2) {
      double result = 0;
      if (num2 == 0) {
          System.out.println("数据不合法！");
          // 手动抛出异常
          throw new AcceptPendingException();
      } else {
          result = num1 / num2;
      }
      return result;
  }
  ```

### 五、调用者处理异常
- 在方法声明处添加异常，使用`throws`
    ```Java
    public void read() throws 				 							  	  FileNotFoundException,ArithmeticException {
        FileInputStream fs = new FileInputStream("a.txt");
    }
    ```
- throw和throws的区别？
  > throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。
  > 而throw则是指抛出的一个具体的异常类型。

### 六、自定义异常类
- 例如：用户取款时，金额不够。
- 书写规则
  + 继承Exception
  + 两个构造（一个无参，一个带参）
  ``` java
  /**
   * 模拟取款余额不足时的异常
   * 自定义异常类
   * @author: liuhao
   * @version 1.0
   */
  public class AccountException extends Exception {

      /**
       * 无参构造
       */
      public AccountException() {
          super();
      }

      /**
       * 带参构造
       * @param message
       */
      public AccountException(String message) {
          super(message);
      }

      /**
       * 重写同String
       */
      public String toString() {
          return "AccountException提示：余额不足";
      }

  }

  //用户账户
  class BankAccound {
      public void withDraw() throws AccountException {
          int balance = 200;// 余额
          int withDraw = 500;// 待取金额
          if (withDraw > balance) {
              throw new AccountException("余额不足");
          }
      }

      /**
       * 主方法测试
       * @param args
       */
      public static void main(String[] args) {
          BankAccound bankAccound = new BankAccound();
          try {
              bankAccound.withDraw();
          } catch (AccountException e) {
              e.printStackTrace();
              System.out.println(e);
              System.out.println(e.getMessage());
          }
      }
  }
  ```
