# 第四章 数据库操作
## 第一节：JDBC
### 一、JDBC背景介绍
#### （一）什么是JDBC？
- JDBC（Java DataBase Connectivity，java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用[Java语言]编写的类和接口组成。
#### （二）JDBC作用是什么？
- 与数据库建立连接、发送 操作数据库的语句并处理结果
- 架起Java与数据库之间的桥梁
#### （三）主要的JDBC API有哪些？
1. 接口
- [Connection]：close() 、commit()、createStatement() 、getAutoCommit() 、isClosed() 、prepareCall(String sql) 、prepareStatement(String sql) 、rollback() 、setAutoCommit(boolean autoCommit)
- [PreparedStatement]：addBatch() 、executeQuery() 、executeUpdate() 、setInt(int parameterIndex, int x) 等一些列set方法、
- [ResultSet]-结果集：absolute(int row) 、afterLast() 、beforeFirst() 、close()
ResultSet释、first() 、一些列get方法、
- [Statement]：开发基本不用，但要清楚
2. 类
- [DriveManager]（驱动程序管理器）：getConnection(String url) 及重载方法
3. 异常
- [SQLException]：
#### （四）JDBC数据操作的步骤？
1. 注册驱动
2. 获取链接
3. 定义SQL语句
4. 准备SQL语句
5. 占位符赋值（可能没有）
6. 执行SQL语句
7. 处理执行结果
8. 关闭链接

### 二、实践操作
#### （一）启动Oracle
1. 启动服务
2. 开启数据库管理工具：sqldeveloper，连接数据库
3. 建表
#### （二)新建一个动态web项目
- DAO：(Data Access Object) 数据访问对象，数据库操作的代码
- 流程
  + JSP(AJAS) -- Servlet -- Service -- DAO -- DB
  + 显示层/视图层（JSP/HTML）-- 控制层(Servlet) -- 业务处理层(Servicr) -- 数据访问层(Dao) -- 数据源(数据库)
- 需要的外部包
  + Log4j：日志
  + JUnit：单元测试
  + Oracle驱动（D:\Software\app\product\11.2.0\dbhome_1\jdbc\lib\ojdbc6.jar）
#### （三）链接数据库
1. Oracle两种连接数据库方式  oci  和 thin
- **oci**
  ```java
  Class.forName("oracle.jdbc.driver.OracleDriver");
  Connection con = DriverManager.getConnection("jdbc:oracle:oci:@数据库名","登录名", "密码");
  ```

- **thin**
  ```java
  Class.forName("oracle.jdbc.OracleDriver");// 注册Oracle驱动，
  String url = "jdbc:oracle:thin:@localhost:1521:orcl";
  // jdbc 数据库协议主协议 thin连接方式 @固定语法 localhost为ip地址 1521为端口号   orcl是Oracle数据库驱动的名称
  Connection conn = DriverManager.getConnection(url, "scott", "scott");// 获得数据库连接
  ```
- 区别
  > 1）从使用上来说，oci必须在客户机上安装oracle客户端或才能连接，而thin就不需要，因此从使用上来讲thin还是更加方便，这也是thin比较常见的原因。
  > 2）原理上来看，thin是纯java实现tcp/ip的c/s通讯；而oci方式,客户端通过native java method调用c library访问服务端，而这个c library就是oci(oracle called interface)，因此这个oci总是需要随着oracle客户端安装（从oracle10.1.0开始，单独提供OCI Instant Client，不用再完整的安装client）
  > 3）它们分别是不同的驱动类别，oci是二类驱动， thin是四类驱动，但它们在功能上并无差异。
  > 4) 如果想要高性能，请使用OCI连接，如果不想装Oracle客户端，请使用thin连接。
  > 5) oci不需要写IP thin需要
2. 链接数据库代码
    ```java
    public class DBUtil {
        /**
         * 获取Oracle数据库链接
         *
         * @return 数据库的链接对象
         */
        public static Connection getConnection() {
            /** 定义一个链接对象，Connection是一个接口 */
            Connection conn = null;
            try {
                /** 注册Oracle驱动，参数是Oracle数据库驱动的名称 */
                Class.forName("oracle.jdbc.OracleDriver");
                /** 链接字符串（主协议、子协议、链接方式） */
                //jdbc 数据库协议主协议
                //thin连接方式
                //@固定语法
                //localhost为ip地址
                //1521为端口号   
                //orcl是Oracle数据库驱动的名称
                String url = "jdbc:oracle:thin:@localhost:1521:orcl";
                /** 获得数据库连接 */
                conn = DriverManager.getConnection(url, "scott", "scott");
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return conn;
        }

        /**
         * 关闭连接
         *
         * @param conn  链接对象
         * @param pstmt 预编译对象
         * @param rs    结果集对象
         */
        public static void close(ResultSet rs, PreparedStatement pstmt, Connection conn) {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (pstmt != null) {
                    pstmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        /*
        * 测试是否可以链接到数据库
        */
        public static void main(String[] args) {
            System.out.println(DBUtil.getConnection());
        }
    }
    ```

#### （四）添删改查（CRUD）
- 详细请参照上传程序
- 例子
  ```java
  /** 检查登陆 */
  public boolean checkUser(String userName, String userPwd) {
      /** 登陆状态：true--成功，false--失败 */
      boolean result = false;
      /** 连接数据库 */
      Connection conn = null;
      /** 预编译对象 */
      PreparedStatement pstmt = null;
      /** 结果集 */
      ResultSet rs = null;
      /** 获取连接 */
      conn = DBUtil.getConnection();
      /** 定义SQL语句 */
      String checkUserSQL = "SELECT * FROM uol_user WHERE username = ? AND userpwd = ?";

      try {
          /** 准备SQL语句/创建一个执行SQL语句的对象 */
          pstmt = conn.prepareStatement(checkUserSQL);
          /** 给参数?赋值 */
          pstmt.setString(1, userName);// 给第一个参数?赋值
          pstmt.setString(2, userPwd);// 给第二个参数?赋值
          /** 执行SQL语句 */
          rs = pstmt.executeQuery();// 执行查询
          // int result = pstmt.executeUpdate();// 执行更新（添加、删除、修改）

          /** 处理执行结果 */
          if (rs.next()) {
              result = true;
          } else {
              result = false;
          }
      } catch (SQLException e) {
          e.printStackTrace();
      } finally {
          DBUtil.close(rs, pstmt, conn);
      }
      return result;
  }
  ```

## 第二节：链接池
### 一、背景介绍
> 实际开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题（并发时），通常情况我们采取连接池技术，来共享连接Connection。在程序开始的时候，可以创建几个连接，将连接放入到连接池中。用户使用连接的时候，可以从连接池中进行获取。用完之后，可以调用 close() 方法将连接[归还]连接池。
#### （一）概念
- 用池来管理Connection，这样可以重复使用Connection。有了池，我们就不用自己来创建Connection，而是通过池来获取Connection对象。当使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池。池就可以再利用这个Connection对象了。
#### （二） 规范
- Java为数据库连接池提供了公共的接口，javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便地切换不同厂商的连接池。
#### （三）为什么使用连接池
1. 对于一个简单的[数据库](http://lib.csdn.net/base/mysql)应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。
2. 连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。
3. 对于共享资源，有一个很著名的设计模式：资源池。该模式正是为了解决资源频繁分配、释放所造成的问题的。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。

#### （四） 数据库连接池技术带来的优势
1. 资源重用
​由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。

2. 更快的系统响应速度
数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。

3. 新的资源分配手段
​对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。

4. 统一的连接管理，避免数据库连接泄漏
较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。

#### （五）连接池的种类
[参考链接](https://blog.csdn.net/bjweimengshu/article/details/80212290)
1. [Druid] 第三方组件（阿里）
- Druid是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能，是一个可用于大数据实时查询和分析的高容错、高性能的开源分布式系统，尤其是当发生代码部署、机器故障以及其他产品系统遇到宕机等情况时，Druid仍能够保持100%正常运行。主要特色：为分析监控设计；快速的交互式查询；高可用；可扩展；Druid是一个开源项目，源码托管在github上。
2. [C3P0] 第三方组件
- 开源的JDBC连接池，实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。单线程，性能较差，适用于小型系统，代码600KB左右。
3. [DBCP]
- 官方说法BoneCP是一个高效、免费、开源的Java数据库连接池实现库。设计初衷就是为了提高数据库连接池性能，根据某些测试数据显示，BoneCP的速度是最快的，要比当时第二快速的连接池快25倍左右，完美集成到一些持久化产品如Hibernate和DataNucleus中。BoneCP特色：高度可扩展，快速；连接状态切换的回调机制；允许直接访问连接；自动化重置能力；JMX支持；懒加载能力；支持XML和属性文件配置方式；较好的Java代码组织，100%单元测试分支代码覆盖率；代码40KB左右。
4. [BoneCP]
- 官方说法BoneCP是一个高效、免费、开源的Java数据库连接池实现库。设计初衷就是为了提高数据库连接池性能，根据某些测试数据显示，BoneCP的速度是最快的，要比当时第二快速的连接池快25倍左右，完美集成到一些持久化产品如Hibernate和DataNucleus中。BoneCP特色：高度可扩展，快速；连接状态切换的回调机制；允许直接访问连接；自动化重置能力；JMX支持；懒加载能力；支持XML和属性文件配置方式；较好的Java代码组织，100%单元测试分支代码覆盖率；代码40KB左右。
5. [Tomcat Jdbc Pool]
- Tomcat在7.0以前都是使用common-dbcp做为连接池组件，但是dbcp是单线程，为保证线程安全会锁整个连接池，性能较差，dbcp有超过60个类，也相对复杂。Tomcat从7.0开始引入了新增连接池模块叫做Tomcat jdbc pool，基于Tomcat JULI，使用Tomcat日志框架，完全兼容dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有8个，支持JMX，支持XA Connection。
4. [Poolman]
- 太古老了


### 二、链接池的实现
#### （一）实现步骤
  1. 导入连接池的jar包
  2. 建立连接池配置文件 `.properties` / `.xml`
  3. 代码中使用
#### （二）配置文件及工具类
1. Druid
- druid.properties
  ```java
  driverClassName=oracle.jdbc.OracleDriver
  url=jdbc:oracle:thin:@localhost:1521:orcl
  username=scott
  password=scott
  # 初始连接池连接数
  initialSize=5
  # 最大连接池数量
  maxActive=10
  # 获取连接时最大等待时间，单位毫秒
  maxWait=3000
  # 最小连接池数量
  minIdle=3
  # 验证连接是否可用
  validationQuery=SELECT 1 FROM dual
  ```
- DBUtil.java
  ```java
  /**
   * 使用Druid连接池获取链接的工具箱
   *
   * @author: liuhao
   * @version 1.0
   */
  public class DBUtilDruid {
      /** 数据源 */
      private static DataSource ds;

      /** 静态代码块，在类加载时候执行 */
      static {
          Properties dbProperties = new Properties();
          try {
              dbProperties.load(DBUtilDruid.class.getResourceAsStream("/druid.properties"));
              ds = DruidDataSourceFactory.createDataSource(dbProperties);
          } catch (IOException e) {
              e.printStackTrace();
          } catch (Exception e) {
              e.printStackTrace();
          }
      }

      /**
       * 获取链接
       *
       * @return 链接对象
       */
      public static Connection getConnection() {
          Connection conn = null;
          try {
              conn = ds.getConnection();
          } catch (SQLException e) {
              e.printStackTrace();
          }
          return conn;
      }

      /**
       * 关闭连接(不是真的关闭，还回操作)
       *
       * @param conn  链接对象
       * @param pstmt 预编译对象
       * @param rs    结果集对象
       */
      public static void close(ResultSet rs, PreparedStatement pstmt, Connection conn) {
          try {
              if (rs != null) {
                  rs.close();
              }
              if (pstmt != null) {
                  pstmt.close();
              }
              if (conn != null) {
                  conn.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
      }

      /**
       * 测试是否可以链接成功
       * @param args 主方法参数
       */
      public static void main(String[] args) {
          System.out.println(DBUtilDruid.getConnection());
      }
  }
  ```
2. C3P0
- c3p0-config.xml
  ```java
  <?xml version="1.0" encoding="UTF-8"?>
  <c3p0-config>
  	<!-- 这是默认配置信息 -->
  	<default-config>
  		<!-- 连接四大参数配置 -->
  		<property name="jdbcUrl">jdbc:oracle:thin:@localhost:1521:orcl
  		</property>
  		<property name="driverClass">oracle.jdbc.OracleDriver</property>
  		<property name="user">scott</property>
  		<property name="password">scott</property>
  		<!-- 池参数配置 -->
  		<property name="acquireIncrement">3</property>
  		<property name="initialPoolSize">10</property>
  		<property name="minPoolSize">2</property>
  		<property name="maxPoolSize">10</property>
  	</default-config>

  	<!-- Mysql配置信息 -->
  	<named-config name="oracle-config">
  		<property name="jdbcUrl">jdbc:mysql://localhost:3306/mydb1</property>
  		<property name="driverClass">com.mysql.jdbc.Driver</property>
  		<property name="user">root</property>
  		<property name="password">123</property>
  		<property name="acquireIncrement">3</property>
  		<property name="initialPoolSize">10</property>
  		<property name="minPoolSize">2</property>
  		<property name="maxPoolSize">10</property>
  	</named-config>
  </c3p0-config>
  ```
- DBUtilC3P0.java
  ```java
  /**
   * 使用C3P0连接池
   *
   * @author liuhao
   * @version 1.0
   */
  public class DBUtilC3P0 {
      /** 数据源 */
      private static DataSource ds = new ComboPooledDataSource();

      /**
       * 获取数据源（连接池）
       *
       * @return 数据源对象，就是连接池
       */
      public static DataSource getDataSource() {
          return ds;
      }

      /**
       * 获取连接
       *
       * @return 数据库连接对象
       */
      public static Connection getConnection() {
          Connection conn = null;
          try {
              conn = ds.getConnection();
          } catch (SQLException e) {
              e.printStackTrace();
          }
          return conn;
      }

      /**
       * 关闭连接
       *
       * @param rs    结果集
       * @param pstmt 预编译对象
       * @param conn  数据库连接
       */
      public static void close(ResultSet rs, PreparedStatement pstmt, Connection conn) {
          try {
              if (rs != null) {
                  rs.close();
              }
              if (pstmt != null) {
                  pstmt.close();
              }
              if (conn != null) {
                  conn.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
      }

      /**
       * 测试是否可以链接成功
       * @param args 主方法参数
       */
      public static void main(String[] args) {
          System.out.println(DBUtilC3P0.getConnection());
      }
  }
  ```
3. 自己实现
- Java连接池代码实现
  ```java
  /**
   * 自定义连接池, 管理连接 代码实现：
   * 1. MyPool.java 连接池类
   * 2. 指定全局参数： 初始化数目、最大连接数、当前连接、 连接池集合
   * 3.构造函数：循环创建3个连接
   * 4. 写一个创建连接的方法
   * 5. 获取连接 ------> 判断： 池中有连接， 直接拿 ------> 池中没有连接，------> 判断，是否达到最大连接数；
   *                    达到，抛出异常；没有达到最大连接数， 创建新的连接
   * 6. 释放连接 ------> 连接放回集合中(..)
   *
   */
  public class MyPool {
      private int init_count = 3; // 初始化连接数目
      private int max_count = 6; // 最大连接数
      private int current_count = 0; // 记录当前使用连接数
      // 连接池 （存放所有的初始化连接）
      private LinkedList<Connection> pool = new LinkedList<Connection>();

      // 1. 构造函数中，初始化连接放入连接池
      public MyPool() {
          // 初始化连接
          for (int i = 0; i < init_count; i++) {
              // 记录当前连接数目
              current_count++;
              // 创建原始的连接对象
              Connection con = createConnection();
              // 把连接加入连接池
              pool.addLast(con);
          }
      }

      // 2. 创建一个新的连接的方法
      private Connection createConnection() {
          try {
              Class.forName("com.mysql.jdbc.Driver");
              // 原始的目标对象
              final Connection con = DriverManager.getConnection("jdbc:mysql:///jdbc_demo", "root", "root");

              /********** 对con对象代理 **************/

              // 对con创建其代理对象
              Connection proxy = (Connection) Proxy.newProxyInstance(

                      con.getClass().getClassLoader(), // 类加载器
                      // con.getClass().getInterfaces(), // 当目标对象是一个具体的类的时候,但是这里con是一个接口
                      new Class[] { Connection.class }, // 目标对象实现的接口

                      new InvocationHandler() { // 当调用con对象方法的时候， 自动触发事务处理器
                          @Override
                          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                              // 方法返回值
                              Object result = null;
                              // 当前执行的方法的方法名
                              String methodName = method.getName();

                              // 判断当执行了close方法的时候，把连接放入连接池
                              if ("close".equals(methodName)) {
                                  System.out.println("begin:当前执行close方法开始！");
                                  // 连接放入连接池
                                  pool.addLast(con);
                                  System.out.println("end: 当前连接已经放入连接池了！");
                              } else {
                                  // 调用目标对象方法
                                  result = method.invoke(con, args);
                              }
                              return result;
                          }
                      });
              return proxy;
          } catch (Exception e) {
              throw new RuntimeException(e);
          }
      }

      // 3. 获取连接
      public Connection getConnection() {

          // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出
          if (pool.size() > 0) {
              return pool.removeFirst();
          }

          // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建；
          if (current_count < max_count) {
              // 记录当前使用的连接数
              current_count++;
              // 创建连接
              return createConnection();
          }

          // 3.3 如果当前已经达到最大连接数，抛出异常
          throw new RuntimeException("当前连接已经达到最大连接数目 ！");
      }

      // 4. 释放连接
      public void realeaseConnection(Connection con) {
          // 4.1 判断： 池的数目如果小于初始化连接，就放入池中
          if (pool.size() < init_count) {
              pool.addLast(con);
          } else {
              try {
                  // 4.2 关闭
                  current_count--;
                  con.close();
              } catch (SQLException e) {
                  throw new RuntimeException(e);
              }
          }
      }

      /**
       * 测试链接
       */
      public static void main(String[] args) throws SQLException {
          MyPool pool = new MyPool();
          System.out.println("当前连接: " + pool.current_count); // 3

          // 使用连接
          pool.getConnection();
          pool.getConnection();
          Connection con4 = pool.getConnection();
          Connection con3 = pool.getConnection();
          Connection con2 = pool.getConnection();
          Connection con1 = pool.getConnection();

          // 释放连接, 连接放回连接池
  //      pool.realeaseConnection(con1);
          /*
           * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】
           * 把连接放入连接池 解决1：实现Connection接口，重写close方法 解决2：动态代理
           */
          con1.close();

          // 再获取
          pool.getConnection();

          System.out.println("连接池：" + pool.pool.size()); // 0
          System.out.println("当前连接: " + pool.current_count); // 3
      }
  }
  ```

#### （三）具体实践
- 详细请参照上传程序
1. CRUD
    ```java
    public boolean checkUser(String userName, String userPwd) {
        /** 登陆状态：true--成功，false--失败 */
        boolean result = false;
        /** 连接数据库 */
        Connection conn = null;
        /** 预编译对象 */
        PreparedStatement pstmt = null;
        /** 结果集 */
        ResultSet rs = null;
        /** 使用链接池获取连接 */
        conn = DBUtilDruid.getConnection();
        /** 定义SQL语句 */
        String checkUserSQL = "SELECT * FROM uol_user WHERE username = ? AND userpwd = ?";

        try {
            /** 准备SQL语句/创建一个执行SQL语句的对象 */
            pstmt = conn.prepareStatement(checkUserSQL);
            /** 给参数?赋值 */
            pstmt.setString(1, userName);// 给第一个参数?赋值
            pstmt.setString(2, userPwd);// 给第二个参数?赋值
            /** 执行SQL语句 */
            rs = pstmt.executeQuery();// 执行查询
            // int result = pstmt.executeUpdate();// 执行更新（添加、删除、修改）

            /** 处理执行结果 */
            if (rs.next()) {
                result = true;
            } else {
                result = false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // 归还连接（不是断掉）
            DBUtilDruid.close(rs, pstmt, conn);
        }
        return result;
    }
    ```
2. 其他SQL语句的执行(DDL等)
    ```java
    String sql = "CREATE TABLE abcdef(id varchar2(10) not null,name varchar(20))";//建表语句
    String sql = "DROP TABLE abcdef";//删表语句
    String sql = "ALTER TABLE abcdef ADD (sex varchar2(1))";//添加类
    String sql = "ALTER TABLE abcdef DROP COLUMN sex";//删除列
    String sql = "ALTER TABLE abcdef MODIFY (sex number(1))";//修改列属性
    String sql = "RENAME abcdef TO ab001";//修改表名
    pstm.execute();//PreparedStatement,返回值boolean类型
    stmt.execute(sql);//Statement
    ```
3. Oracle分页显示：
    ```java
    SELECT *  FROM (SELECT ROWNUM AS rowno, t.*
              FROM emp t
              WHERE   ROWNUM <= 5) table_alias
              WHERE table_alias.rowno >= 1;
    ```
4. 批量删除，批量添加，批量修改
5. 执行DDL语句，创建临时表，通过代码，用完删除
6. 获取元数据
- DatabaseMetaData接口:获取数据库相关信息
  > DatabaseMetaData dbms = conn.getMetaData();//创建
  + getDatabaseProductVersion
  + getDatabaseProductName
  + getDriverName
  + getDriverVersion
  + getUserName
  + getURL
- ResultSetMetaData接口:获取结果集相关信息
  > ResultSetMetaData rsmd = rs.getMetaData();//创建
  + getColumnCount
  + getColumnName(i)
  + getColumnClassName(i)
7. 结果集分页：可滚动的结果集，绝对定位，conn.prepareStrtement(sql, ResultSet.xxx, ResultSet.xxx)，参数一定要写
ORM---双向同步，读（表-内存）改（内存）写（内存-磁盘）

8. 事务：ACID（属性）
- 如果设置了手动提交事务，执行完更新需要提事务

9. 配置：属性文件 Blob和Clob
- CLOB：Character Large Object，大的字符对象
常见场景：保存XML文档
方法：
setAsciiStream(int parameterIndex, InputStream x, long length)
getAsciiStream(String columnLabel)
- BLOB: Binary Large Object,大的二进制对象
常见场景：保存位图
方法：
setBinaryStream(int parameterIndex, InputStream x, int length)
getBinaryStream(String columnLabel)
10. SQL注入攻击（SQL Injection）
    > 简介：
    > 用户输入的字符串中包含了SQL指令，破坏了原SQL语句的原意，从而可以恶意登录
    > 如userName = "1' OR '1'='1"; passWord = "1' OR '1'='1";
    > 防护：
    > 用户输入时，正则验证不允许'='或'出现
    > 接收端判断
- PreparedStatement引入：
  + 继承自Statement接口，stmt能做的pstmt都可以替代
  + SQL中未知内容使用?代替，并使用setString( , )给?设置具体的值，防止了注入的发生
- 预编译的优势：
  + 它会先将SQL语句发送给数据库进行预编译，对于相似的操作语句，他只需要预编译一次，减少编译次数
  + 安全性高，没有SQL注入风险
  + 没有SQL字符串拼接，可读性好

## 第三节：MyBatis
### 一、背景介绍
> 在2010年6月16日，iBATIS团队决定从apache迁出并迁移到Google Code，并更名为MyBatis。目前iBATIS 2.x和MyBatis 3不是100%兼容的，如配置文件的DTD变更，SqlMapClient直接由SqlSessionFactory代替了，包名也有com.ibatis变成org.ibatis等等。

1. MyBatis是一个框架，是一个第三方组件，开源的
2. 作用：用于持久化操作（数据库），是一个ORM工具。
3. 负责数据库操作的事情，MyBatis 底层依赖于JDBC
4. MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。
5. 相关网站：
- 官网：http://www.mybatis.org
- 中文开发文档：http://www.mybatis.org/mybatis-3/zh/index.html
- 中文官网（国人）：http://www.mybatis.cn/
- MyBatis源码、jar包下载：[参考链接](https://blog.csdn.net/brave_monkey/article/details/79612174)

### 二、ORM是什么
1. 全称：Object Relational Mapping  对象关系映射
2. 理解：Object--Java对象  Relational--Java和数据库  Mapping--映射
2.  类--表   对象--一条记录  属性--字段  内存--硬盘
3. 常见ORM框架：MyBatis、Hibernate、JPA
- [x] MyBatis： 半自动的ORM工具，轻量级ORM工具，需要自己写SQL语句
- [x] Hibernate（冬眠）：全自动，重量级，可以不写SQL语句，灵活性较低，性能较低
- [x] JPA：Java Persistence API的简称,是JDK 5.0注解或XML描述对象－关系表的映射关系，将运行期的实体对象持久化到数据库中
4. 术语：POJO、JavaBean
- [x] POJO：简单的Java对象，实际就是普通JavaBeans是。例如Users类--简单属性和简单方法（com.ychs.uol.vo.User、com.ychs.uol.model.User、com.ychs.uol.do.User）
- [x] Java Bean 命名规则(属性)：
  - 第一个单词的首字母必须小写，且单词长度大于1
  - 第二个单词首字母大写其余小写

### 三、为什么使用MyBatis？
1. 将SQL语句从Java代码中分离出，独立存放，做到解耦的效果，便于维护
2. 减少了代码量

### 四、使用MyBatis
- [x] mybatis 3.5.2 API : [参考链接](http://www.mybatis.org/mybatis-3/zh/apidocs/index.html?tdsourcetag=s_pctim_aiomsg)
> XML:可扩展标记语言

#### 实践步骤
1. 导包(MyBatis的jar包)
2. 两个配置文件
  - jdbc.properties
  - mybatis-config.xml
3. 数据库建表
4. 准备POJO/JavaBean---实体类
5. 写Mapper接口
6. 写配置文件：xxx.xml
  - 注意链接的<类名>--使用全限定的类名（包名+类名）
  - 注意链接的<方法名>还有<方法参数类型>
  - <SQL语句>的书写以及<参数>的获取：#{属性名}
7. Dao实用类
  - 获取工厂
  - 定义接口对象（动态代理模式）
  - 调用接口中的方法
8. Test测试类
  - JUnit的使用
  - Log4j使用
#### 准备
1. xml添删改查`<insert>`、`<delete>`、`<update>`、`<select>`标签属性
  - id="xxxx" ——表示此段sql执行语句的唯一标识，也是接口的方法名称【必须一致才能找到】
  - parameterType="xxxx" ——表示该sql语句中需要传入的参数， 类型要与对应的接口方法的类型一致【可选】
  - resultMap="xxx"—— 定义出参，调用已定义的<resultMap>映射管理器的id值
  - resultType="xxxx"——定义出参，匹配普通Java类型或自定义的pojo【出参类型若不指定，将为语句类型默认类型，如<insert>语句返回值为int】
2. 注意： 至于为何<insert><delete><update> 语句的返回值类型为什么是int，有过JDBC操作经验的朋友可能会有印象，增删改操作实际上返回的是操作的条数（受影响的条数）。而Mybatis框架本身是基于JDBC的，所以此处也沿袭这种返回值类型。

#### （一）添加用户
```java
<!-- 添加用户 -->
<!-- id中的insertUser就是UserMapper接口中的方法名；parameterType的值指的是insertUser方法带的参数类型，使用全限定的类名 -->
<insert id="insertUser" parameterType="com.ychs.uol.model.User">
  INSERT INTO uol_user(userid, username, userpwd, realname, sex, job,
  remark, status)
  VALUES(sys_guid(),#{userName},#{userPwd},#{realName},#{sex},#{job},#{remark},#{status})
  <!-- 特别注意：SQL语句后绝对不能加分号 -->
</insert>
```

#### （二）删除用户
```java
<!-- 删除用户 -->
<delete id="deleteUserByUserid" parameterType="String">
  DELETE FROM users
  WHERE userid=#{userid}
</delete>
```

#### （三）修改用户
```java
<!-- 修改用户 -->
<update id="modifyUser" parameterType="com.ychs.uol.model.User">
  UPDATE uol_user SET
  username = #{userName}, userpwd = #{userPwd},realname =
  #{realName},sex = #{sex},job = #{job},remark = #{remark}, status =
  #{status} WHERE userid = #{userId}
</update>
```

#### （四）查询用户
- 查询所有用户
```java
<!-- 查询所有用户 -->
<select id="selectAllUser" resultMap="userMap">
  SELECT * FROM uol_user
</select>

<!-- 自定义返回结果集类型，命名为：userMap，建立uol_user表字段和User类属性之间的映射关系 -->
<resultMap id="userMap" type="com.ychs.uol.model.User">
    <!-- 主键 -->
    <id property="userId" column="userid" />
    <!-- 非主键 -->
    <result property="userName" column="username" />
    <result property="userPwd" column="userpsw" />
    <result property="realName" column="realname" />
    <result property="sex" column="sex" />
    <result property="job" column="job" />
    <result property="remark" column="remark" />
    <result property="status" column="status" />
</resultMap>
```
#### （五）传参（多个参数）
1. 方式一：#{0}、#{1}、#{2}
    > 注意：不同版本之间使用方式不同，在3.4版本之后使用：#{arg0}、#{arg1}、#{arg2}
    > [参考链接](https://blog.csdn.net/mrliar17/article/details/76079450?tdsourcetag=s_pctim_aiomsg)

- MyBatis3.4版本之前
    ```Java
    <!-- 方式1: 使用序号传参 -->
    <select id="selectBook" resultType="com.ychs.uol.vo.Book">
      SELECT * FROM book WHERE bookname=#{0} AND publisher=#{1}
    </select>
    ```
- MyBatis3.4.4版本之后
    ```Java
    <!-- 方式1: 使用序号传参 -->
    <select id="selectBook" resultType="com.ychs.uol.vo.Book">
      SELECT * FROM book WHERE bookname=#{arg0} AND publisher=#{arg1}
    </select>
    ```
2. 方式二：使用MyBise注解
    ```Java
    //xml
      <!-- 方式2: 使用参数注解@Param -->
      <select id="selectBookByAnnotation"
        resultType="com.ychs.uol.vo.Book">
        SELECT * FROM book WHERE bookname=#{bname} AND publisher=#{pubname}
      </select>

    //dao
      public Book selectBookByAnnotation(@Param("bname") String bookname, @Param("pubname") String publisher) {
          SqlSession sqlSession =DBUtil.getSession();
          Book book = null;
          try {
            BookMapper bookMapper = sqlSession.getMapper(BookMapper.class);
            book = bookMapper.selectBookByAnnotation(bookname, publisher);
          } catch (Exception e) {
            e.printStackTrace();
          } finally {
            sqlSession.close();
          }
          return book;
      }
    ```
3. 方式三：使用Map(常用)
    ```Java
    <!-- 方式3: 使用Map传参 -->
    <select id="selectBookByMap" parameterType="java.util.Map"
      resultType="com.ychs.uol.vo.Book">
      SELECT * FROM book WHERE bookname=#{bname} AND publisher=#{pubname}
    </select>
    ```
4. 方式四：传对象(常用)
    ```Java
    <!-- 方式4: 使用JavaBean传参 -->
    <select id="selectBookByBean"
      parameterType="com.ychs.uol.vo.Book" resultType="com.ychs.uol.vo.Book">
      SELECT * FROM book WHERE bookname=#{bookname} AND publisher=#{publisher}
    </select>
    ```

#### （六）多表链接查询
- eg：专业所属院系、学校(school、department、major）
  ```java
  <resultMap id="infoMap" type="com.ychs.uol.model.Info">
    <result property="schoolName" column="schoolname" />
    <result property="deptName" column="deptname" />
    <result property="majorName" column="majorname" />
  </resultMap>

  <select id="seleteMajorInfo" resultMap="infoMap"
    parameterType="String">
    SELECT s.schoolname, d.deptname, m.majorname FROM
    uol_major m INNER JOIN
    uol_department d ON m.deptid = d.deptid INNER
    JOIN uol_school s ON
    d.schoolid = s.schoolid
    WHERE m.majorname=#{majorName}
  </select>
  ```

#### （七）多条件组合查询
1. 方式一（SQL中写WHERE1=1）
    ```java
    <!-- 多条件组合查询 -->
    <select id="selectLabMember" parameterType="java.util.Map" resultMap="labMemberMap">
        SELECT * FROM uol_labmember WHERE 1=1
        <if test="memberName != null">
        	AND membername LIKE #{memberName}
        </if>
        <if test="grade != null">
        	AND grade = #{grade}
        </if>
        <if test="school != null">
        	AND school = #{school}
        </if>
    </select>
    ```
2. 方式二（使用`<where>`标签）
    ```java
    <!-- 多条件组合查询 -->
    <select id="selectLabMember" parameterType="java.util.Map" resultMap="labMemberMap">
        SELECT * FROM uol_labmember
        <where>
            <if test="memberName != null">
              AND membername LIKE #{memberName}
            </if>
            <if test="grade != null">
              AND grade = #{grade}
            </if>
            <if test="school != null">
              AND school = #{school}
            </if>
        </where>
    </select>
    ```
#### （八）分页显示
1. 方式一：使用MyBatis自带的类

    ```java
    //xml
      <!-- 分页显示，方式一：使用MyBaits自带的类 -->
      <select id="selectUserPage" resultMap="userMap">
        SELECT * FROM uol_user
      </select>

    //dao
      public List<User> selectUserPage(int currPage, int pageSize) {
          List<User> userList = new ArrayList<User>();
          SqlSession sqlSession = DBUtil.getSession();
          // 偏移量，当前页第一条记录的序号（从0开始）
          int offset = (currPage - 1) * pageSize;
          try {
              UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
              userList = userMapper.selectUserPage(new RowBounds(offset, pageSize));
              sqlSession.commit();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              DBUtil.closeSession(sqlSession);
          }
          return userList;
      }

    ```
2. 方式二：自己写sql(使用伪列)
    ```java
    //xml
      <!-- 分页显示，方式二：自己写SQL语句，通过参数控制 -->
      <select id="selectUserPageSql" resultMap="userMap">
        SELECT * FROM (SELECT
        ROWNUM AS rowno, u.* FROM uol_user u WHERE ROWNUM &lt;= #{arg1})
        WHERE rowno   &gt;= #{arg0}
      </select>

    //dao
      public List<User> selectUserPageSql(int currPage, int pageSize) {
          List<User> userList = new ArrayList<User>();
          SqlSession sqlSession = DBUtil.getSession();
          // 当前页第一条记录的序号（从1开始）
          int begin = (currPage - 1) * pageSize + 1;
          // 当前页最后一条记录的序号
          int end = begin + (pageSize - 1);
          try {
              UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
              userList = userMapper.selectUserPageSql(begin, end);
              sqlSession.commit();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              DBUtil.closeSession(sqlSession);
          }
          return userList;
      }
    ```

### 五、使用MyBatis（二）

#### （一）自增主键
- [参考链接](https://blog.csdn.net/xu1916659422/article/details/77921912)
- 主键分类
  - 自然主键：没有实际意义，只是一种唯一标识
    + Oracle :使用序列
    + MySQL：自增
    + 随机数生成主键（随机数生成的种子）
    + UUID：32位的序列
  - 业务主键：带有实际意义，学号，身份证

-  `<selectKey>`标签
    属性|描述
    |:--:|:--|
    |keyProperty|selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。对应实体类中的主键的属性|
    |keyColumn|匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。|
    |resultType|结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。|
    |order|这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素|
    |statementType|与前面相同，MyBatis 支持 STATEMENT（直接操作sql，不进行预编译，获取数据---${xxx}），PREPARED（预处理，参数，进行预编译，获取数据---#{xxx}） 和 CALLABLE（执行存储过程） 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。|
- 代码：
  ```java
  <!-- 添加用户，主键自增 -->
  <insert id="insertUserKeyAutoInc"
    parameterType="com.ychs.uol.model.User">
    <selectKey keyProperty="userId" resultType="String"
      keyColumn="userNo" order="BEFORE">
      SELECT myseq.nextval as userNo FROM dual
      <!-- SELECT MAX(userid)+1 AS userNo FROM uol_user -->
    </selectKey>
    INSERT INTO uol_user(userid, username, userpwd, realname, sex, job,
    remark, status)
    VALUES(#{userId},#{userName},#{userPwd},#{realName},#{sex},#{job},#{remark},#{status})
  </insert>
  ```

#### （二）批量删除
1. `<foreach>`标签
    |属性|描述|
    |:--:|:--:|
    |collection|指定输入对象中集合属性<br>|
    |item|每次遍历生成的对象|
    |open|开始遍历时拼接的串|
    |close|结束遍历时两个对象需要拼接的串|
    |separator|表示隔离符号|
    |index|集合迭代位置|
2. collection 属性详解
  - 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list
  - 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array
  - 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在breast里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key
- 代码：
  ```java
  <!-- 批量删除用户 -->
  <delete id="deleteUserBatch" parameterType="java.util.List">
      DELETE FROM uol_user WHERE userid IN
      <foreach collection="list" item="item" open="(" separator="," close=")">
          #{item}
      </foreach>
  </delete>
  ```

#### （三）选择一个条件进行查询
- 使用`<choose>`、`<when>`、`<otherwise>`标签
  ```java
  <!-- 多条件查询用户（只能使用一个条件） -->
  <select id="selectUserMulCondition"
      parameterType="java.util.Map" resultMap="userMap">
      SELECT * FROM uol_user WHERE 1 =1
      <choose>
          <when test="userName != null">
              AND username = #{userName}
          </when>
          <when test="realName != null">
              AND realname = #{realName}
          </when>
          <when test="sex != null">
              AND sex = #{sex}
          </when>
          <otherwise>
              AND sex = '女'
          </otherwise>
      </choose>
  </select>
  ```
####（四）更新时sql动态拼装
- 使用`<set>`、`<if>`标签
  ```java
  <!-- 动态SQL: set，动态包含需要更新的列，舍去其它的 -->
  <update id="updateUserIfNecessary"
      parameterType="com.ychs.uol.model.User">
      UPDATE uol_user
      <set>
          <if test="userName != null">username=#{userName},</if>
          <if test="userPwd != null">userpsw=#{userPwd},</if>
          <if test="realName != null">realname=#{realName},</if>
          <if test="sex != null">sex=#{sex},</if>
          <if test="job != null">job=#{job},</if>
          <if test="remark != null">remark=#{remark},</if>
          <if test="status != null">status=#{status}</if>
      </set>
      WHERE userid=#{userId}
  </update>
  ```

#### （四）模糊查询
1. 使用`${}`直接获取，不经过预编译
    ```java
      <!-- 模糊查询，第一种写法 realname LIKE '%xxx%' 用$——不预编译 -->
      <select id="selectUserLike" parameterType="String" resultMap="userMap">
        SELECT * FROM uol_user WHERE username LIKE '%${words}%'
      </select>
    ```

2. 使用`||`链接
    ```java
    <!-- 模糊查询，第二种写法,使用Oracle字符串连接符|| -->
    <select id="selectUserLike" parameterType="String" resultMap="userMap">
      SELECT * FROM uol_user WHERE username LIKE '%'||#{words}||'%'
    </select>
    ```

3. 使用`CONCAT()`数据库函数链接
    ```java
    <!-- 模糊查询，第三种写法 -->
    <select id="selectUserLike" parameterType="String" resultMap="userMap">
      SELECT * FROM uol_user WHERE username LIKE CONCAT(CONCAT('%',#{words}),'%')
    </select>
    ```

#### （五）级联删除
1. 调用接口中方法方式
    ```java
    public int deleteSchool(String schoolName) {
        int result = 0;
        SqlSession sqlSession = null;

        try {
            sqlSession = DBUtil.getSession();
            // 定义三个Mapper
            SchoolMapper schoolMapper = sqlSession.getMapper(SchoolMapper.class);
            DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class);
            MajorMapper majorMapper = sqlSession.getMapper(MajorMapper.class);
            // 删除专业
            majorMapper.deleteMajor(schoolName);
            // 删除系部
            departmentMapper.deleteDepartment(schoolName);
            // 删除学校
            result = schoolMapper.deleteSchool(schoolName);
            sqlSession.commit();
        } catch (Exception e) {
            sqlSession.rollback();
            e.printStackTrace();
        } finally {
            DBUtil.closeSession(sqlSession);
        }
        return result;
    }
    ```
2. 使用触发器
- 使用一个触发器
  ```sql
  create or replace TRIGGER DELETE_SCHOOL
  BEFORE DELETE ON uol_school
  FOR EACH ROW
  DECLARE
  pragma autonomous_transaction;-- 加入一个自治事务
  BEGIN
      DELETE uol_major WHERE deptid IN (SELECT deptid FROM uol_department WHERE schoolid IN (SELECT schoolid FROM uol_school WHERE schoolname = :old.schoolname));
      DELETE uol_department WHERE schoolid IN (SELECT schoolid FROM uol_school WHERE schoolname = :old.schoolname);
      commit;
  END;
  ```
- 使用两个触发器
  ```sql
  create or replace TRIGGER DELETE_SCHOOL
  BEFORE DELETE ON uol_school
  FOR EACH ROW
  BEGIN
      DELETE uol_department WHERE schoolid = :old.schoolid;
  END;
  ```
  ```sql
  create or replace TRIGGER DELETE_DEPARTMENT
  BEFORE DELETE ON uol_department
  FOR EACH ROW
  BEGIN
      DELETE uol_major WHERE deptid = :old.deptid;
  END;
  ```


### 六、FAQ
#### （一）uuid是什么
- UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写
- UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为16^32=2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。
- 目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID）
#### （二）xml文件里如何使用‘>’，‘<’ ？
- [参考链接](https://blog.csdn.net/qq_26599807/article/details/52126377)
- 使用转义字符‘>’---`&gt;`,  ‘<’---`&lt;`
#### （三）Mybatis常用的xml标签
- [参考链接](https://blog.csdn.net/qq_41426442/article/details/79663467)
#### （四）ssh和ssm的区别
- [参考链接](https://blog.csdn.net/xxk666/article/details/83446702)
- ssh通常使用 Struts2为控制器(controller) ，spring 为事务层(service)， hibernate 负责持久层（dao）
- ssm通常使用 springMVC为控制器(controller) ，spring 为事务层(service)， MyBatis 负责持久层（dao）

### 七、MyBatis面试题
#### （一）什么是MyBatis?
1. Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。

2. MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

3. 通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。

#### （二）Mybatis的优点
1. 把sql语句从数据库中独立出来，解除sql与程序代码之间耦合，便于代码的维护和管理。
2. 编写原生SQL语句，更加的灵活。
3. 提供XML标签（where、set、if、choose、when、otherwise、foreach、trim、bind），支持编写动态SQL语句，并可重用。
4. 封装了底层的JDBC，API调用，很好的与各种数据库兼容，并且能将结果自动的转化成JavaBean对象（结果集与java对象自动映射），简化了数据库编程的重复工作。
5. 能够与Spring很好的集成。

#### （三）Mybatis的缺点
1. SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。
2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

#### （四）MyBatis适用场合
1. MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。
2. 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。

#### （五）MyBatis核心类的作用?
> [参考链接](https://www.cnblogs.com/WHL5/p/8675281.html)
> 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。

| 类名 | 作用 |
| :-------------: | :------------- |
| SqlSessionFactoryBuilder | 读取全局配置文件，得到数据源信息，创建连接工厂SqlSessionFactory。它的特点是，当创建了SqlSessionFactory对象之后，这个类就不需要了。因此，它的最佳范围是存在于方法体内，也就是局部变量。 |
| SqlSessionFactory | 连接工厂；创建SqlSession实例的工厂。它的特点是，SqlSessionFactory对象一旦被创建，就无法销毁或者再创建，是单例的。因此，它存在于应用程序的整个运行生命周期 |
| SqlSession | 会话对象类，是一个接口，SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。SqlSession对应着一次数据库会话，所以每次访问数据库时都需要在SqlSessionFactory实例的openSession()方法中创建它。但一个SqlSession会话也可以执行多次SQL语句。注意：一个连接不能让多个线程同时使用,因为是非线程安全的，每个线程都应该有一个SqlSession的实例来完成对数据库的操作 |
| Mapper      | 1.映射类，跟映射关系对应，是从SqlSession中获取的。<br/>2.作为接口的代理类 <br/>3.将传入的接口类型与映射的XML文件关联起来，接口的实现是基于XML配置文件中的SQL实现，生成代理类对象 <br/>4.函数：session.getMapper(接口 class 实例) |

#### （六）MyBatis 的工作流程或运行原理?
1. 通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件中构建出SqlSessionFactory。
2. SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句。
3. 完成数据库的CRUD操作和事务提交，关闭SqlSession。


#### （七）MyBatis跟Hibernate的比较
1. MyBatis 是半自动化的,需要我们手动的编写sql。
2. Hibernate是全自动化的,只要配置映射文件,可以为我们动态的生成sql。

#### （八）`#{}`和`${}`的区别是什么？
1. `${}`：简单字符串替换（属于静态文本替换），把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句（非预编译）。一种使用情况：用于传入数据库对象，比如表名。
2. `#{}`：预编译处理，sql中的#{}替换成 ‘?’ （占位符），补全预编译语句，有效的防止Sql语句注入，这种取值是编译好sql语句再取值。

#### （九）Mybatis是如何进行分页的？分页插件的原理是什么？
1. 使用 MyBatis 提供的 RowBounds 对象进行分页。
2. 自己写分页 sql 语句实现分页。
3. 使用分页插件：分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。eg：`select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10`

#### （十）什么是MyBatis的接口绑定,有什么好处
- 答：接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。

#### （十一）接口绑定有几种实现方式,分别是怎么实现的?
1. 接口绑定有两种实现方式：
- 一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定。
- 另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。

#### （十二）什么情况下用注解绑定,什么情况下用xml绑定
答：
- 当Sql语句比较简单时候,用注解绑定。
- 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。

#### （十三）MyBatis里面的动态Sql是怎么设定的?用什么语法?
答：MyBatis里面的动态Sql一般是通过if节点来实现，通过OGNL语法来实现，但是如果要写的完整，必须配合where、trim节点，where节点是判断包含节点有内容就插入where，否则不插入，trim节点是用来判断如果动态语句是以and 或or开始，那么会自动把这个and或者or取掉 。

#### （十四）Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
- 答：还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim | where | set | foreach | if | choose | when | otherwise | bind 等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。

#### （十五）Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？
答：
- Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。
- 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。

#### （十六）Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
答：
- 第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。
- 第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。有了列名与属性名的映射关系后，Mybatis通过**反射**创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

#### （十七）Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
答：
- 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。

- 原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。

#### （十八）Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？
答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。
原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。



3. ORM 思想是什么，有什么好处？
	- 将数据库代码和Java代码分离，实现解耦，便于维护
	- [参考文章](https://blog.csdn.net/orecle_littleboy/article/details/82458956)
4. 常见的ORM框架有哪些？
	- MyBatis：流行，在SSM中使用
	- Hibernate：sql固定生成，不够灵活。
	- JPA：java持久化API
	- [SSH和SSM区别](https://blog.csdn.net/xxk666/article/details/83446702)

5. MyBatis中使用到哪些设计模式？
- 工厂模式
- 代理模式（动态代理）

两种调用sql方式
  1.直接通过sqlSesson调用添删改查方法，带有侵入性，不能面向接口编程
  2. 使用接口来进行
  3. 使用注解：没有xml，零配置，但是改动需要编译

### 八、进阶面试题
#### （一）MyBatis比IBatis比较大的几个改进是什么
1. 有接口绑定,包括注解绑定sql和xml绑定Sql ,
2. 动态sql由原来的节点配置变成OGNL表达式,
3. 在一对一，一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置

#### （二）MyBatis实现一对一有几种方式?具体怎么操作的
答：有联合查询和嵌套查询，分别如下
- 联合查询是几个表联合查询,只查询一次，通过在resultMap里面配置association节点配置一对一的类就可以完成。
- 嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。

#### （三）IBatis和MyBatis在核心处理类分别叫什么
答：
- IBatis里面的核心处理类交SqlMapClient
- MyBatis里面的核心处理类叫做SqlSession

#### （四）讲下MyBatis的缓存
答：MyBatis的缓存分为一级缓存和二级缓存，分别如下：

- 一级缓存放在session里面，默认就有。
- 二级缓存放在它的命名空间里，默认是打开的。使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置

#### （五）最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
答：
- Dao接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中 MappedStatement 的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个`<select>、<insert>、<update>、<delete>`标签，都会被解析为一个MappedStatement对象。
- Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
- Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

#### （六）简述Mybatis的插件运行原理，以及如何编写一个插件。
答：
- Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
- 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

#### （七）Mybatis执行批量插入，能返回数据库主键列表吗？
- 答：能，JDBC都能，Mybatis当然也能。

#### （八）Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
答：
- Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

- 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

#### （九）Mybatis中如何执行批处理？
- 答：使用BatchExecutor完成批处理。

#### （十）Mybatis都有哪些Executor执行器？它们之间的区别是什么？
答：
- Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
- SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
- ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
- BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
- 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。

#### （十一）Mybatis中如何指定使用哪一种Executor执行器？
答：
- 在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。

#### （十二）Mybatis是否可以映射Enum枚举类？
答：
- Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。

#### （十三）简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？
- 答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个`<select>、<insert>、<update>、<delete>`标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
